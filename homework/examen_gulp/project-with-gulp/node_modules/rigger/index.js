var async = require('async');
var debug = require('debug')('rigger');
var getit = require('getit');
var Stream = require('stream').Stream;
var fs = require('fs');
var path = require('path');
var util = require('util');
var mod = require('module');
var aliases = require('buildjs.core/aliases');
var regexes = require('buildjs.core/regexes');
var formatters = require('buildjs.core/formatters');
var platform = require('buildjs.core/platform');
var _ = require('underscore');

// initialise the default converters
var converters = {};

// initialise the concatenators
var concatenators = {
  js: ';' + platform.lineEnding,
  default: platform.lineEnding
};

// initialise comments pre and post that will be injected when creating
// additional comment lines
var defaultCommentSyntax = { pre: '//' };
var commentTypes = {
  css:     { pre: '/*', post: '*/' },
  coffee:  { pre: '#' }
};

/**
# Class: Rigger > Stream

Create a new class of Rigger that will be used to parse a input source file and
produce a parsed output file.

## Valid Options

- filetype {String} - (default: js) the type of file that we are processing (js, coffee, css, roy, etc)
- encoding {String} - (default: utf8) file encoding
- cwd {String} - The current working directory
*/
function Rigger(opts) {
  // call the inherited Stream constructor
  Stream.call(this);

  // save a reference to the options
  // these options will be passed through to getit calls
  opts = this.opts = _.extend({}, opts);

  // initialise the base settings that will be passed through to include calls
  this.baseSettings = _.extend({}, opts.settings);

  // initialise the tolerant setting to false
  this.tolerant = opts.tolerant === true;

  // initialise the basename from the opts
  this.basename = opts.basename;

  // initialise the default file format
  this.filetype = formatters.normalizeExt(opts.filetype || 'js');
  debug('filetype initialized to: ' + this.filetype);

  // initialise the concatenator based on the filetype
  this.concatenator = concatenators[this.filetype] || concatenators['default'];

  // initialise the encoding (default to utf8)
  this.encoding = this.opts.encoding || 'utf8';

  // initialise the line ending
  this.lineEnding = this.opts.lineEnding || platform.lineEnding;

  // initialise the cwd (this is also used by getit)
  this.cwd = this.opts.cwd || process.cwd();
  this.csd = this.opts.csd || this.cwd;

  // initiliase the include pattern
  this.patterns = this.opts.patterns || regexes.includes[this.filetype] || regexes.includes.js;

  // initialise the stream as writable
  this.writable = true;

  // create a resolving queue to track resolving includes progress
  this.activeIncludes = 0;

  // initialise the context, if not explicitly defined, match the filetype
  this.targetType = formatters.normalizeExt(this.opts.targetType || this.filetype);

  // initialise the buffer to empty
  this.buffer = '';

  // initialise the converters
  this.converters = _.defaults(opts.converters || {}, converters);

  // create the output array
  this.output = [];

  // initialise whether directives should be included or not
  this.useDirectives = opts.useDirectives || false;
}

util.inherits(Rigger, Stream);

Rigger.prototype.convert = function(conversion, input, opts, callback) {
  var steps;
  var ii;

  // ensure we have options
  if (typeof opts == 'function') {
    callback = opts;
    opts = {};
  }

  // if we have no conversion required, simply return the input back
  if (typeof conversion == 'undefined') return callback(null, input);

  // get the converter
  steps = [].concat(this.converters[conversion] || []);

  // if we don't have a converter, then return an error
  if (steps.length === 0) return callback(new Error('Unable to run conversion from ' + conversion));

  // add the first step in the waterfall
  debug('attempting tp apply conversion of: ' + conversion);
  steps.unshift(function(itemCb) {
    itemCb(null, input, opts);
  });

  // bind the steps
  for (ii = 0; ii < steps.length; ii++) {
    steps[ii] = steps[ii].bind(this);
  }

  // start the conversion pr