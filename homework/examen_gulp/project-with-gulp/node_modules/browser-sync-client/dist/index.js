/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/after/index.js":
/*!*************************************!*\
  !*** ./node_modules/after/index.js ***!
  \*************************************/
/***/ ((module) => {

eval("module.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/after/index.js?");

/***/ }),

/***/ "./node_modules/arraybuffer.slice/index.js":
/*!*************************************************!*\
  !*** ./node_modules/arraybuffer.slice/index.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/arraybuffer.slice/index.js?");

/***/ }),

/***/ "./lib/browser.utils.ts":
/*!******************************!*\
  !*** ./lib/browser.utils.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction getWindow() {\n    return window;\n}\nexports.getWindow = getWindow;\n/**\n * @returns {HTMLDocument}\n */\nfunction getDocument() {\n    return document;\n}\nexports.getDocument = getDocument;\n/**\n * Get the current x/y position crossbow\n * @returns {{x: *, y: *}}\n */\nfunction getBrowserScrollPosition(window, document) {\n    var scrollX;\n    var scrollY;\n    var dElement = document.documentElement;\n    var dBody = document.body;\n    if (window.pageYOffset !== undefined) {\n        scrollX = window.pageXOffset;\n        scrollY = window.pageYOffset;\n    }\n    else {\n        scrollX = dElement.scrollLeft || dBody.scrollLeft || 0;\n        scrollY = dElement.scrollTop || dBody.scrollTop || 0;\n    }\n    return {\n        x: scrollX,\n        y: scrollY\n    };\n}\nexports.getBrowserScrollPosition = getBrowserScrollPosition;\n/**\n * @returns {{x: number, y: number}}\n */\nfunction getDocumentScrollSpace(document) {\n    var dElement = document.documentElement;\n    var dBody = document.body;\n    return {\n        x: dBody.scrollHeight - dElement.clientWidth,\n        y: dBody.scrollHeight - dElement.clientHeight\n    };\n}\nexports.getDocumentScrollSpace = getDocumentScrollSpace;\n/**\n * Saves scroll position into cookies\n */\nfunction saveScrollPosition(window, document) {\n    var pos = getBrowserScrollPosition(window, document);\n    document.cookie = \"bs_scroll_pos=\" + [pos.x, pos.y].join(\",\");\n}\nexports.saveScrollPosition = saveScrollPosition;\n/**\n * Restores scroll position from cookies\n */\nfunction restoreScrollPosition() {\n    var pos = getDocument()\n        .cookie.replace(/(?:(?:^|.*;\\s*)bs_scroll_pos\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\")\n        .split(\",\");\n    getWindow().scrollTo(Number(pos[0]), Number(pos[1]));\n}\nexports.restoreScrollPosition = restoreScrollPosition;\n/**\n * @param tagName\n * @param elem\n * @returns {*|number}\n */\nfunction getElementIndex(tagName, elem) {\n    var allElems = getDocument().getElementsByTagName(tagName);\n    return Array.prototype.indexOf.call(allElems, elem);\n}\nexports.getElementIndex = getElementIndex;\n/**\n * Force Change event on radio & checkboxes (IE)\n */\nfunction forceChange(elem) {\n    elem.blur();\n    elem.focus();\n}\nexports.forceChange = forceChange;\n/**\n * @param elem\n * @returns {{tagName: (elem.tagName|*), index: *}}\n */\nfunction getElementData(elem) {\n    var tagName = elem.tagName;\n    var index = getElementIndex(tagName, elem);\n    return {\n        tagName: tagName,\n        index: index\n    };\n}\nexports.getElementData = getElementData;\n/**\n * @param {string} tagName\n * @param {number} index\n */\nfunction getSingleElement(tagName, index) {\n    var elems = getDocument().getElementsByTagName(tagName);\n    return elems[index];\n}\nexports.getSingleElement = getSingleElement;\n/**\n * Get the body element\n */\nfunction getBody() {\n    return getDocument().getElementsByTagName(\"body\")[0];\n}\nexports.getBody = getBody;\n/**\n * @param {{x: number, y: number}} pos\n */\nfunction setScroll(pos) {\n    getWindow().scrollTo(pos.x, pos.y);\n}\nexports.setScroll = setScroll;\n/**\n * Hard reload\n */\nfunction reloadBrowser() {\n    getWindow().location.reload(true);\n}\nexports.reloadBrowser = reloadBrowser;\n/**\n * Foreach polyfill\n * @param coll\n * @param fn\n */\nfunction forEach(coll, fn) {\n    for (var i = 0, n = coll.length; i < n; i += 1) {\n        fn(coll[i], i, coll);\n    }\n}\nexports.forEach = forEach;\n/**\n * Are we dealing with old IE?\n * @returns {boolean}\n */\nfunction isOldIe() {\n    return typeof getWindow().attachEvent !== \"undefined\";\n}\nexports.isOldIe = isOldIe;\n/**\n * Split the URL information\n * @returns {object}\n */\nfunction getLocation(url) {\n    var location = getDocument().createElement(\"a\");\n    location.href = url;\n    if (location.host === \"\") {\n        location.href = location.href;\n    }\n    return location;\n}\nexports.getLocation = getLocation;\n/**\n * @param {String} val\n * @returns {boolean}\n */\nfunction isUndefined(val) {\n    return \"undefined\" === typeof val;\n}\nexports.isUndefined = isUndefined;\n/**\n * @param obj\n * @param path\n */\nfunction getByPath(obj, path) {\n    for (var i = 0, tempPath = path.split(\".\"), len = tempPath.length; i < len; i++) {\n        if (!obj || typeof obj !== \"object\") {\n            return false;\n        }\n        obj = obj[tempPath[i]];\n    }\n    if (typeof obj === \"undefined\") {\n        return false;\n    }\n    return obj;\n}\nexports.getByPath = getByPath;\nfunction getScrollPosition(window, document) {\n    var pos = getBrowserScrollPosition(window, document);\n    return {\n        raw: pos,\n        proportional: getScrollTopPercentage(pos, document) // Get % of y axis of scroll\n    };\n}\nexports.getScrollPosition = getScrollPosition;\nfunction getScrollPositionForElement(element) {\n    var raw = {\n        x: element.scrollLeft,\n        y: element.scrollTop\n    };\n    var scrollSpace = {\n        x: element.scrollWidth,\n        y: element.scrollHeight\n    };\n    return {\n        raw: raw,\n        proportional: getScrollPercentage(scrollSpace, raw).y // Get % of y axis of scroll\n    };\n}\nexports.getScrollPositionForElement = getScrollPositionForElement;\nfunction getScrollTopPercentage(pos, document) {\n    var scrollSpace = getDocumentScrollSpace(document);\n    var percentage = getScrollPercentage(scrollSpace, pos);\n    return percentage.y;\n}\nexports.getScrollTopPercentage = getScrollTopPercentage;\nfunction getScrollPercentage(scrollSpace, scrollPosition) {\n    var x = scrollPosition.x / scrollSpace.x;\n    var y = scrollPosition.y / scrollSpace.y;\n    return {\n        x: x || 0,\n        y: y\n    };\n}\nexports.getScrollPercentage = getScrollPercentage;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/browser.utils.ts?");

/***/ }),

/***/ "./lib/dom-effects.ts":
/*!****************************!*\
  !*** ./lib/dom-effects.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar _a;\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar prop_set_dom_effect_1 = __webpack_require__(/*! ./dom-effects/prop-set.dom-effect */ \"./lib/dom-effects/prop-set.dom-effect.ts\");\nvar style_set_dom_effect_1 = __webpack_require__(/*! ./dom-effects/style-set.dom-effect */ \"./lib/dom-effects/style-set.dom-effect.ts\");\nvar link_replace_dom_effect_1 = __webpack_require__(/*! ./dom-effects/link-replace.dom-effect */ \"./lib/dom-effects/link-replace.dom-effect.ts\");\nvar set_scroll_dom_effect_1 = __webpack_require__(/*! ./dom-effects/set-scroll.dom-effect */ \"./lib/dom-effects/set-scroll.dom-effect.ts\");\nvar set_window_name_dom_effect_1 = __webpack_require__(/*! ./dom-effects/set-window-name.dom-effect */ \"./lib/dom-effects/set-window-name.dom-effect.ts\");\nvar Events;\n(function (Events) {\n    Events[\"PropSet\"] = \"@@BSDOM.Events.PropSet\";\n    Events[\"StyleSet\"] = \"@@BSDOM.Events.StyleSet\";\n    Events[\"LinkReplace\"] = \"@@BSDOM.Events.LinkReplace\";\n    Events[\"SetScroll\"] = \"@@BSDOM.Events.SetScroll\";\n    Events[\"SetWindowName\"] = \"@@BSDOM.Events.SetWindowName\";\n})(Events = exports.Events || (exports.Events = {}));\nexports.domHandlers$ = new BehaviorSubject_1.BehaviorSubject((_a = {},\n    _a[Events.PropSet] = prop_set_dom_effect_1.propSetDomEffect,\n    _a[Events.StyleSet] = style_set_dom_effect_1.styleSetDomEffect,\n    _a[Events.LinkReplace] = link_replace_dom_effect_1.linkReplaceDomEffect,\n    _a[Events.SetScroll] = set_scroll_dom_effect_1.setScrollDomEffect,\n    _a[Events.SetWindowName] = set_window_name_dom_effect_1.setWindowNameDomEffect,\n    _a));\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/dom-effects.ts?");

/***/ }),

/***/ "./lib/dom-effects/link-replace.dom-effect.ts":
/*!****************************************************!*\
  !*** ./lib/dom-effects/link-replace.dom-effect.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar Log = __webpack_require__(/*! ../log */ \"./lib/log.ts\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar dom_effects_1 = __webpack_require__(/*! ../dom-effects */ \"./lib/dom-effects.ts\");\nfunction linkReplaceDomEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$.pipe(pluck_1.pluck(\"injectNotification\"))), filter_1.filter(function (_a) {\n        var inject = _a[1];\n        return inject;\n    }), map_1.map(function (_a) {\n        var incoming = _a[0], inject = _a[1];\n        var message = \"[LinkReplace] \" + incoming.basename;\n        if (inject === \"overlay\") {\n            return Log.overlayInfo(message);\n        }\n        return Log.consoleInfo(message);\n    }));\n}\nexports.linkReplaceDomEffect = linkReplaceDomEffect;\nfunction linkReplace(incoming) {\n    return [dom_effects_1.Events.LinkReplace, incoming];\n}\nexports.linkReplace = linkReplace;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/dom-effects/link-replace.dom-effect.ts?");

/***/ }),

/***/ "./lib/dom-effects/prop-set.dom-effect.ts":
/*!************************************************!*\
  !*** ./lib/dom-effects/prop-set.dom-effect.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar dom_effects_1 = __webpack_require__(/*! ../dom-effects */ \"./lib/dom-effects.ts\");\nvar Log = __webpack_require__(/*! ../log */ \"./lib/log.ts\");\nfunction propSetDomEffect(xs) {\n    return xs.pipe(tap_1.tap(function (event) {\n        var target = event.target, prop = event.prop, value = event.value;\n        target[prop] = value;\n    }), map_1.map(function (e) {\n        return Log.consoleInfo(\"[PropSet]\", e.target, e.prop + \" = \" + e.pathname);\n    }));\n}\nexports.propSetDomEffect = propSetDomEffect;\nfunction propSet(incoming) {\n    return [dom_effects_1.Events.PropSet, incoming];\n}\nexports.propSet = propSet;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/dom-effects/prop-set.dom-effect.ts?");

/***/ }),

/***/ "./lib/dom-effects/set-scroll.dom-effect.ts":
/*!**************************************************!*\
  !*** ./lib/dom-effects/set-scroll.dom-effect.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ignoreElements_1 = __webpack_require__(/*! rxjs/operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar dom_effects_1 = __webpack_require__(/*! ../dom-effects */ \"./lib/dom-effects.ts\");\nfunction setScroll(x, y) {\n    return [dom_effects_1.Events.SetScroll, { x: x, y: y }];\n}\nexports.setScroll = setScroll;\nfunction setScrollDomEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.window$), tap_1.tap(function (_a) {\n        var event = _a[0], window = _a[1];\n        return window.scrollTo(event.x, event.y);\n    }), ignoreElements_1.ignoreElements());\n}\nexports.setScrollDomEffect = setScrollDomEffect;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/dom-effects/set-scroll.dom-effect.ts?");

/***/ }),

/***/ "./lib/dom-effects/set-window-name.dom-effect.ts":
/*!*******************************************************!*\
  !*** ./lib/dom-effects/set-window-name.dom-effect.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ignoreElements_1 = __webpack_require__(/*! rxjs/operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar dom_effects_1 = __webpack_require__(/*! ../dom-effects */ \"./lib/dom-effects.ts\");\nfunction setWindowNameDomEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.window$), tap_1.tap(function (_a) {\n        var value = _a[0], window = _a[1];\n        return (window.name = value);\n    }), ignoreElements_1.ignoreElements());\n}\nexports.setWindowNameDomEffect = setWindowNameDomEffect;\nfunction setWindowName(incoming) {\n    return [dom_effects_1.Events.SetWindowName, incoming];\n}\nexports.setWindowName = setWindowName;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/dom-effects/set-window-name.dom-effect.ts?");

/***/ }),

/***/ "./lib/dom-effects/style-set.dom-effect.ts":
/*!*************************************************!*\
  !*** ./lib/dom-effects/style-set.dom-effect.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar dom_effects_1 = __webpack_require__(/*! ../dom-effects */ \"./lib/dom-effects.ts\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar Log = __webpack_require__(/*! ../log */ \"./lib/log.ts\");\nfunction styleSetDomEffect(xs) {\n    return xs.pipe(tap_1.tap(function (event) {\n        var style = event.style, styleName = event.styleName, newValue = event.newValue;\n        style[styleName] = newValue;\n    }), map_1.map(function (e) { return Log.consoleInfo(\"[StyleSet] \" + e.styleName + \" = \" + e.pathName); }));\n}\nexports.styleSetDomEffect = styleSetDomEffect;\nfunction styleSet(incoming) {\n    return [dom_effects_1.Events.StyleSet, incoming];\n}\nexports.styleSet = styleSet;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/dom-effects/style-set.dom-effect.ts?");

/***/ }),

/***/ "./lib/effects.ts":
/*!************************!*\
  !*** ./lib/effects.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar _a;\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar set_options_effect_1 = __webpack_require__(/*! ./effects/set-options.effect */ \"./lib/effects/set-options.effect.ts\");\nvar file_reload_effect_1 = __webpack_require__(/*! ./effects/file-reload.effect */ \"./lib/effects/file-reload.effect.ts\");\nvar browser_set_location_effect_1 = __webpack_require__(/*! ./effects/browser-set-location.effect */ \"./lib/effects/browser-set-location.effect.ts\");\nvar simulate_click_effect_1 = __webpack_require__(/*! ./effects/simulate-click.effect */ \"./lib/effects/simulate-click.effect.ts\");\nvar set_element_value_effect_1 = __webpack_require__(/*! ./effects/set-element-value.effect */ \"./lib/effects/set-element-value.effect.ts\");\nvar set_element_toggle_value_effect_1 = __webpack_require__(/*! ./effects/set-element-toggle-value.effect */ \"./lib/effects/set-element-toggle-value.effect.ts\");\nvar set_scroll_1 = __webpack_require__(/*! ./effects/set-scroll */ \"./lib/effects/set-scroll.ts\");\nvar browser_reload_effect_1 = __webpack_require__(/*! ./effects/browser-reload.effect */ \"./lib/effects/browser-reload.effect.ts\");\nvar EffectNames;\n(function (EffectNames) {\n    EffectNames[\"FileReload\"] = \"@@FileReload\";\n    EffectNames[\"PreBrowserReload\"] = \"@@PreBrowserReload\";\n    EffectNames[\"BrowserReload\"] = \"@@BrowserReload\";\n    EffectNames[\"BrowserSetLocation\"] = \"@@BrowserSetLocation\";\n    EffectNames[\"BrowserSetScroll\"] = \"@@BrowserSetScroll\";\n    EffectNames[\"SetOptions\"] = \"@@SetOptions\";\n    EffectNames[\"SimulateClick\"] = \"@@SimulateClick\";\n    EffectNames[\"SetElementValue\"] = \"@@SetElementValue\";\n    EffectNames[\"SetElementToggleValue\"] = \"@@SetElementToggleValue\";\n})(EffectNames = exports.EffectNames || (exports.EffectNames = {}));\nexports.effectOutputHandlers$ = new BehaviorSubject_1.BehaviorSubject((_a = {},\n    _a[EffectNames.SetOptions] = set_options_effect_1.setOptionsEffect,\n    _a[EffectNames.FileReload] = file_reload_effect_1.fileReloadEffect,\n    _a[EffectNames.BrowserReload] = browser_reload_effect_1.browserReloadEffect,\n    _a[EffectNames.BrowserSetLocation] = browser_set_location_effect_1.browserSetLocationEffect,\n    _a[EffectNames.SimulateClick] = simulate_click_effect_1.simulateClickEffect,\n    _a[EffectNames.SetElementValue] = set_element_value_effect_1.setElementValueEffect,\n    _a[EffectNames.SetElementToggleValue] = set_element_toggle_value_effect_1.setElementToggleValueEffect,\n    _a[EffectNames.BrowserSetScroll] = set_scroll_1.setScrollEffect,\n    _a));\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects.ts?");

/***/ }),

/***/ "./lib/effects/browser-reload.effect.ts":
/*!**********************************************!*\
  !*** ./lib/effects/browser-reload.effect.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar effects_1 = __webpack_require__(/*! ../effects */ \"./lib/effects.ts\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nfunction browserReload() {\n    return [effects_1.EffectNames.BrowserReload];\n}\nexports.browserReload = browserReload;\nfunction preBrowserReload() {\n    return [effects_1.EffectNames.PreBrowserReload];\n}\nexports.preBrowserReload = preBrowserReload;\nfunction browserReloadEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.window$), tap_1.tap(function (_a) {\n        var window = _a[1];\n        return window.location.reload(true);\n    }));\n}\nexports.browserReloadEffect = browserReloadEffect;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects/browser-reload.effect.ts?");

/***/ }),

/***/ "./lib/effects/browser-set-location.effect.ts":
/*!****************************************************!*\
  !*** ./lib/effects/browser-set-location.effect.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ignoreElements_1 = __webpack_require__(/*! rxjs/operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar effects_1 = __webpack_require__(/*! ../effects */ \"./lib/effects.ts\");\nfunction browserSetLocationEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.window$), tap_1.tap(function (_a) {\n        var event = _a[0], window = _a[1];\n        if (event.path) {\n            return (window.location =\n                window.location.protocol +\n                    \"//\" +\n                    window.location.host +\n                    event.path);\n        }\n        if (event.url) {\n            return (window.location = event.url);\n        }\n    }), ignoreElements_1.ignoreElements());\n}\nexports.browserSetLocationEffect = browserSetLocationEffect;\nfunction browserSetLocation(input) {\n    return [effects_1.EffectNames.BrowserSetLocation, input];\n}\nexports.browserSetLocation = browserSetLocation;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects/browser-set-location.effect.ts?");

/***/ }),

/***/ "./lib/effects/file-reload.effect.ts":
/*!*******************************************!*\
  !*** ./lib/effects/file-reload.effect.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar effects_1 = __webpack_require__(/*! ../effects */ \"./lib/effects.ts\");\nvar Reloader_1 = __webpack_require__(/*! ../../vendor/Reloader */ \"./vendor/Reloader.ts\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar mergeMap_1 = __webpack_require__(/*! rxjs/operators/mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\nfunction fileReload(event) {\n    return [effects_1.EffectNames.FileReload, event];\n}\nexports.fileReload = fileReload;\n/**\n * Attempt to reload files in place\n * @param xs\n * @param inputs\n */\nfunction fileReloadEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$, inputs.document$, inputs.navigator$), mergeMap_1.mergeMap(function (_a) {\n        var event = _a[0], options = _a[1], document = _a[2], navigator = _a[3];\n        return Reloader_1.reload(document, navigator)(event, {\n            tagNames: options.tagNames,\n            liveCSS: true,\n            liveImg: true\n        });\n    }));\n}\nexports.fileReloadEffect = fileReloadEffect;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects/file-reload.effect.ts?");

/***/ }),

/***/ "./lib/effects/set-element-toggle-value.effect.ts":
/*!********************************************************!*\
  !*** ./lib/effects/set-element-toggle-value.effect.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar effects_1 = __webpack_require__(/*! ../effects */ \"./lib/effects.ts\");\nfunction setElementToggleValueEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.document$), tap_1.tap(function (_a) {\n        var event = _a[0], document = _a[1];\n        var elems = document.getElementsByTagName(event.tagName);\n        var match = elems[event.index];\n        if (match) {\n            if (event.type === \"radio\") {\n                match.checked = true;\n            }\n            if (event.type === \"checkbox\") {\n                match.checked = event.checked;\n            }\n            if (event.tagName === \"SELECT\") {\n                match.value = event.value;\n            }\n        }\n    }));\n}\nexports.setElementToggleValueEffect = setElementToggleValueEffect;\nfunction setElementToggleValue(event) {\n    return [effects_1.EffectNames.SetElementToggleValue, event];\n}\nexports.setElementToggleValue = setElementToggleValue;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects/set-element-toggle-value.effect.ts?");

/***/ }),

/***/ "./lib/effects/set-element-value.effect.ts":
/*!*************************************************!*\
  !*** ./lib/effects/set-element-value.effect.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar effects_1 = __webpack_require__(/*! ../effects */ \"./lib/effects.ts\");\nfunction setElementValueEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.document$), tap_1.tap(function (_a) {\n        var event = _a[0], document = _a[1];\n        var elems = document.getElementsByTagName(event.tagName);\n        var match = elems[event.index];\n        if (match) {\n            match.value = event.value;\n        }\n    }));\n}\nexports.setElementValueEffect = setElementValueEffect;\nfunction setElementValue(event) {\n    return [effects_1.EffectNames.SetElementValue, event];\n}\nexports.setElementValue = setElementValue;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects/set-element-value.effect.ts?");

/***/ }),

/***/ "./lib/effects/set-options.effect.ts":
/*!*******************************************!*\
  !*** ./lib/effects/set-options.effect.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ignoreElements_1 = __webpack_require__(/*! rxjs/operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar effects_1 = __webpack_require__(/*! ../effects */ \"./lib/effects.ts\");\n/**\n * Set the local client options\n * @param xs\n * @param inputs\n */\nfunction setOptionsEffect(xs, inputs) {\n    return xs.pipe(tap_1.tap(function (options) { return inputs.option$.next(options); }), \n    // map(() => consoleInfo('set options'))\n    ignoreElements_1.ignoreElements());\n}\nexports.setOptionsEffect = setOptionsEffect;\nfunction setOptions(options) {\n    return [effects_1.EffectNames.SetOptions, options];\n}\nexports.setOptions = setOptions;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects/set-options.effect.ts?");

/***/ }),

/***/ "./lib/effects/set-scroll.ts":
/*!***********************************!*\
  !*** ./lib/effects/set-scroll.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar ignoreElements_1 = __webpack_require__(/*! rxjs/operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\nvar partition_1 = __webpack_require__(/*! rxjs/operators/partition */ \"./node_modules/rxjs/operators/partition.js\");\nvar merge_1 = __webpack_require__(/*! rxjs/observable/merge */ \"./node_modules/rxjs/observable/merge.js\");\nvar browser_utils_1 = __webpack_require__(/*! ../browser.utils */ \"./lib/browser.utils.ts\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nfunction setScrollEffect(xs, inputs) {\n    {\n        /**\n         * Group the incoming event with window, document & scrollProportionally argument\n         */\n        var tupleStream$ = xs.pipe(withLatestFrom_1.withLatestFrom(inputs.window$, inputs.document$, inputs.option$.pipe(pluck_1.pluck(\"scrollProportionally\"))));\n        /**\n         * Split the stream between document scrolls and element scrolls\n         */\n        var _a = partition_1.partition(function (_a) {\n            var event = _a[0];\n            return event.tagName === \"document\";\n        })(tupleStream$), document$ = _a[0], element$ = _a[1];\n        /**\n         * Further split the element scroll between those matching in `scrollElementMapping`\n         * and regular element scrolls\n         */\n        var _b = partition_1.partition(function (_a) {\n            var event = _a[0];\n            return event.mappingIndex > -1;\n        })(element$), mapped$ = _b[0], nonMapped$ = _b[1];\n        return merge_1.merge(\n        /**\n         * Main window scroll\n         */\n        document$.pipe(tap_1.tap(function (incoming) {\n            var event = incoming[0], window = incoming[1], document = incoming[2], scrollProportionally = incoming[3];\n            var scrollSpace = browser_utils_1.getDocumentScrollSpace(document);\n            if (scrollProportionally) {\n                return window.scrollTo(0, scrollSpace.y * event.position.proportional); // % of y axis of scroll to px\n            }\n            return window.scrollTo(0, event.position.raw.y);\n        })), \n        /**\n         * Regular, non-mapped Element scrolls\n         */\n        nonMapped$.pipe(tap_1.tap(function (incoming) {\n            var event = incoming[0], window = incoming[1], document = incoming[2], scrollProportionally = incoming[3];\n            var matchingElements = document.getElementsByTagName(event.tagName);\n            if (matchingElements && matchingElements.length) {\n                var match = matchingElements[event.index];\n                if (match) {\n                    return scrollElement(match, scrollProportionally, event);\n                }\n            }\n        })), \n        /**\n         * Element scrolls given in 'scrollElementMapping'\n         */\n        mapped$.pipe(withLatestFrom_1.withLatestFrom(inputs.option$.pipe(pluck_1.pluck(\"scrollElementMapping\"))), \n        /**\n         * Filter the elements in the option `scrollElementMapping` so\n         * that it does not contain the element that triggered the event\n         */\n        map_1.map(function (_a) {\n            var incoming = _a[0], scrollElementMapping = _a[1];\n            var event = incoming[0];\n            return [\n                incoming,\n                scrollElementMapping.filter(function (item, index) { return index !== event.mappingIndex; })\n            ];\n        }), \n        /**\n         * Now perform the scroll on all other matching elements\n         */\n        tap_1.tap(function (_a) {\n            var incoming = _a[0], scrollElementMapping = _a[1];\n            var event = incoming[0], window = incoming[1], document = incoming[2], scrollProportionally = incoming[3];\n            scrollElementMapping\n                .map(function (selector) { return document.querySelector(selector); })\n                .forEach(function (element) {\n                scrollElement(element, scrollProportionally, event);\n            });\n        }))).pipe(ignoreElements_1.ignoreElements());\n    }\n}\nexports.setScrollEffect = setScrollEffect;\nfunction scrollElement(element, scrollProportionally, event) {\n    if (scrollProportionally && element.scrollTo) {\n        return element.scrollTo(0, element.scrollHeight * event.position.proportional); // % of y axis of scroll to px\n    }\n    return element.scrollTo(0, event.position.raw.y);\n}\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects/set-scroll.ts?");

/***/ }),

/***/ "./lib/effects/simulate-click.effect.ts":
/*!**********************************************!*\
  !*** ./lib/effects/simulate-click.effect.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ignoreElements_1 = __webpack_require__(/*! rxjs/operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar effects_1 = __webpack_require__(/*! ../effects */ \"./lib/effects.ts\");\nfunction simulateClickEffect(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.window$, inputs.document$), tap_1.tap(function (_a) {\n        var event = _a[0], window = _a[1], document = _a[2];\n        var elems = document.getElementsByTagName(event.tagName);\n        var match = elems[event.index];\n        if (match) {\n            if (document.createEvent) {\n                window.setTimeout(function () {\n                    var evObj = document.createEvent(\"MouseEvents\");\n                    evObj.initEvent(\"click\", true, true);\n                    match.dispatchEvent(evObj);\n                }, 0);\n            }\n            else {\n                window.setTimeout(function () {\n                    if (document.createEventObject) {\n                        var evObj = document.createEventObject();\n                        evObj.cancelBubble = true;\n                        match.fireEvent(\"on\" + \"click\", evObj);\n                    }\n                }, 0);\n            }\n        }\n    }), ignoreElements_1.ignoreElements());\n}\nexports.simulateClickEffect = simulateClickEffect;\nfunction simulateClick(event) {\n    return [effects_1.EffectNames.SimulateClick, event];\n}\nexports.simulateClick = simulateClick;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/effects/simulate-click.effect.ts?");

/***/ }),

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar zip_1 = __webpack_require__(/*! rxjs/observable/zip */ \"./node_modules/rxjs/observable/zip.js\");\nvar socket_1 = __webpack_require__(/*! ./socket */ \"./lib/socket.ts\");\nvar notify_1 = __webpack_require__(/*! ./notify */ \"./lib/notify.ts\");\nvar dom_effects_1 = __webpack_require__(/*! ./dom-effects */ \"./lib/dom-effects.ts\");\nvar socket_messages_1 = __webpack_require__(/*! ./socket-messages */ \"./lib/socket-messages.ts\");\nvar merge_1 = __webpack_require__(/*! rxjs/observable/merge */ \"./node_modules/rxjs/observable/merge.js\");\nvar log_1 = __webpack_require__(/*! ./log */ \"./lib/log.ts\");\nvar effects_1 = __webpack_require__(/*! ./effects */ \"./lib/effects.ts\");\nvar scroll_restore_1 = __webpack_require__(/*! ./scroll-restore */ \"./lib/scroll-restore.ts\");\nvar listeners_1 = __webpack_require__(/*! ./listeners */ \"./lib/listeners.ts\");\nvar groupBy_1 = __webpack_require__(/*! rxjs/operators/groupBy */ \"./node_modules/rxjs/operators/groupBy.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar mergeMap_1 = __webpack_require__(/*! rxjs/operators/mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\nvar share_1 = __webpack_require__(/*! rxjs/operators/share */ \"./node_modules/rxjs/operators/share.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar of_1 = __webpack_require__(/*! rxjs/observable/of */ \"./node_modules/rxjs/observable/of.js\");\nvar window$ = socket_1.initWindow();\nvar document$ = socket_1.initDocument();\nvar names$ = scroll_restore_1.initWindowName(window);\nvar _a = socket_1.initSocket(), socket$ = _a.socket$, io$ = _a.io$;\nvar option$ = socket_1.initOptions();\nvar navigator$ = of_1.of(navigator);\nvar notifyElement$ = notify_1.initNotify(option$.getValue());\nvar logInstance$ = log_1.initLogger(option$.getValue());\nvar outgoing$ = listeners_1.initListeners(window, document, socket$, option$);\nvar inputs = {\n    window$: window$,\n    document$: document$,\n    socket$: socket$,\n    option$: option$,\n    navigator$: navigator$,\n    notifyElement$: notifyElement$,\n    logInstance$: logInstance$,\n    io$: io$,\n    outgoing$: outgoing$\n};\nfunction getStream(name, inputs) {\n    return function (handlers$, inputStream$) {\n        return inputStream$.pipe(groupBy_1.groupBy(function (_a) {\n            var keyName = _a[0];\n            return keyName;\n        }), withLatestFrom_1.withLatestFrom(handlers$), filter_1.filter(function (_a) {\n            var x = _a[0], handlers = _a[1];\n            return typeof handlers[x.key] === \"function\";\n        }), mergeMap_1.mergeMap(function (_a) {\n            var x = _a[0], handlers = _a[1];\n            return handlers[x.key](x.pipe(pluck_1.pluck(String(1))), inputs);\n        }), share_1.share());\n    };\n}\nvar combinedEffectHandler$ = zip_1.zip(effects_1.effectOutputHandlers$, scroll_restore_1.scrollRestoreHandlers$, function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.reduce(function (acc, item) { return (__assign({}, acc, item)); }, {});\n});\nvar output$ = getStream(\"[socket]\", inputs)(socket_messages_1.socketHandlers$, merge_1.merge(inputs.socket$, outgoing$));\nvar effect$ = getStream(\"[effect]\", inputs)(combinedEffectHandler$, output$);\nvar dom$ = getStream(\"[dom-effect]\", inputs)(dom_effects_1.domHandlers$, merge_1.merge(effect$, names$));\nvar merged$ = merge_1.merge(output$, effect$, dom$);\nvar log$ = getStream(\"[log]\", inputs)(log_1.logHandler$, merged$);\nlog$.subscribe();\n// resume$.next(true);\n// var socket = require(\"./socket\");\n// var shims = require(\"./client-shims\");\n// var notify = require(\"./notify\");\n// // var codeSync = require(\"./code-sync\");\n// const { BrowserSync } = require(\"./browser-sync\");\n// var ghostMode = require(\"./ghostmode\");\n// var events = require(\"./events\");\n// var utils = require(\"./browser.utils\");\n//\n// const mitt = require(\"mitt\").default;\n//\n// var shouldReload = false;\n// var initialised = false;\n//\n// /**\n//  * @param options\n//  */\n// function init(options: bs.InitOptions) {\n//     if (shouldReload && options.reloadOnRestart) {\n//         utils.reloadBrowser();\n//     }\n//\n//     var BS = window.___browserSync___ || {};\n//     var emitter = mitt();\n//\n//     if (!BS.client) {\n//         BS.client = true;\n//\n//         var browserSync = new BrowserSync({ options, emitter, socket });\n//\n//         // codeSync.init(browserSync);\n//\n//         // // Always init on page load\n//         // ghostMode.init(browserSync);\n//         //\n//         // notify.init(browserSync);\n//         //\n//         // if (options.notify) {\n//         //     notify.flash(\"Connected to BrowserSync\");\n//         // }\n//     }\n//\n//     // if (!initialised) {\n//     //     socket.on(\"disconnect\", function() {\n//     //         if (options.notify) {\n//     //             notify.flash(\"Disconnected from BrowserSync\");\n//     //         }\n//     //         shouldReload = true;\n//     //     });\n//     //     initialised = true;\n//     // }\n// }\n//\n// /**\n//  * Handle individual socket connections\n//  */\n// socket.on(\"connection\", init);\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/index.ts?");

/***/ }),

/***/ "./lib/listeners.ts":
/*!**************************!*\
  !*** ./lib/listeners.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar merge_1 = __webpack_require__(/*! rxjs/observable/merge */ \"./node_modules/rxjs/observable/merge.js\");\nvar form_inputs_listener_1 = __webpack_require__(/*! ./listeners/form-inputs.listener */ \"./lib/listeners/form-inputs.listener.ts\");\nvar clicks_listener_1 = __webpack_require__(/*! ./listeners/clicks.listener */ \"./lib/listeners/clicks.listener.ts\");\nvar scroll_listener_1 = __webpack_require__(/*! ./listeners/scroll.listener */ \"./lib/listeners/scroll.listener.ts\");\nvar form_toggles_listener_1 = __webpack_require__(/*! ./listeners/form-toggles.listener */ \"./lib/listeners/form-toggles.listener.ts\");\nfunction initListeners(window, document, socket$, option$) {\n    var merged$ = merge_1.merge(scroll_listener_1.getScrollStream(window, document, socket$, option$), clicks_listener_1.getClickStream(document, socket$, option$), form_inputs_listener_1.getFormInputStream(document, socket$, option$), form_toggles_listener_1.getFormTogglesStream(document, socket$, option$));\n    return merged$;\n}\nexports.initListeners = initListeners;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/listeners.ts?");

/***/ }),

/***/ "./lib/listeners/clicks.listener.ts":
/*!******************************************!*\
  !*** ./lib/listeners/clicks.listener.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./lib/utils.ts\");\nvar socket_messages_1 = __webpack_require__(/*! ../socket-messages */ \"./lib/socket-messages.ts\");\nvar browser_utils_1 = __webpack_require__(/*! ../browser.utils */ \"./lib/browser.utils.ts\");\nvar ClickEvent = __webpack_require__(/*! ../messages/ClickEvent */ \"./lib/messages/ClickEvent.ts\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar skip_1 = __webpack_require__(/*! rxjs/operators/skip */ \"./node_modules/rxjs/operators/skip.js\");\nvar distinctUntilChanged_1 = __webpack_require__(/*! rxjs/operators/distinctUntilChanged */ \"./node_modules/rxjs/operators/distinctUntilChanged.js\");\nvar switchMap_1 = __webpack_require__(/*! rxjs/operators/switchMap */ \"./node_modules/rxjs/operators/switchMap.js\");\nvar fromEvent_1 = __webpack_require__(/*! rxjs/observable/fromEvent */ \"./node_modules/rxjs/observable/fromEvent.js\");\nvar empty_1 = __webpack_require__(/*! rxjs/observable/empty */ \"./node_modules/rxjs/observable/empty.js\");\nfunction getClickStream(document, socket$, option$) {\n    var canSync$ = utils_1.createTimedBooleanSwitch(socket$.pipe(filter_1.filter(function (_a) {\n        var name = _a[0];\n        return name === socket_messages_1.IncomingSocketNames.Click;\n    })));\n    return option$.pipe(skip_1.skip(1), // initial option set before the connection event\n    pluck_1.pluck(\"ghostMode\", \"clicks\"), distinctUntilChanged_1.distinctUntilChanged(), switchMap_1.switchMap(function (canClick) {\n        if (!canClick) {\n            return empty_1.empty();\n        }\n        return fromEvent_1.fromEvent(document, \"click\", true).pipe(map_1.map(function (e) { return e.target; }), filter_1.filter(function (target) {\n            if (target.tagName === \"LABEL\") {\n                var id = target.getAttribute(\"for\");\n                if (id && document.getElementById(id)) {\n                    return false;\n                }\n            }\n            return true;\n        }), withLatestFrom_1.withLatestFrom(canSync$), filter_1.filter(function (_a) {\n            var canSync = _a[1];\n            return canSync;\n        }), map_1.map(function (_a) {\n            var target = _a[0];\n            return ClickEvent.outgoing(browser_utils_1.getElementData(target));\n        }));\n    }));\n}\nexports.getClickStream = getClickStream;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/listeners/clicks.listener.ts?");

/***/ }),

/***/ "./lib/listeners/form-inputs.listener.ts":
/*!***********************************************!*\
  !*** ./lib/listeners/form-inputs.listener.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar socket_messages_1 = __webpack_require__(/*! ../socket-messages */ \"./lib/socket-messages.ts\");\nvar browser_utils_1 = __webpack_require__(/*! ../browser.utils */ \"./lib/browser.utils.ts\");\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./lib/utils.ts\");\nvar KeyupEvent = __webpack_require__(/*! ../messages/KeyupEvent */ \"./lib/messages/KeyupEvent.ts\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar skip_1 = __webpack_require__(/*! rxjs/operators/skip */ \"./node_modules/rxjs/operators/skip.js\");\nvar distinctUntilChanged_1 = __webpack_require__(/*! rxjs/operators/distinctUntilChanged */ \"./node_modules/rxjs/operators/distinctUntilChanged.js\");\nvar switchMap_1 = __webpack_require__(/*! rxjs/operators/switchMap */ \"./node_modules/rxjs/operators/switchMap.js\");\nvar empty_1 = __webpack_require__(/*! rxjs/observable/empty */ \"./node_modules/rxjs/observable/empty.js\");\nvar fromEvent_1 = __webpack_require__(/*! rxjs/observable/fromEvent */ \"./node_modules/rxjs/observable/fromEvent.js\");\nfunction getFormInputStream(document, socket$, option$) {\n    var canSync$ = utils_1.createTimedBooleanSwitch(socket$.pipe(filter_1.filter(function (_a) {\n        var name = _a[0];\n        return name === socket_messages_1.IncomingSocketNames.Keyup;\n    })));\n    return option$.pipe(skip_1.skip(1), // initial option set before the connection event\n    pluck_1.pluck(\"ghostMode\", \"forms\", \"inputs\"), distinctUntilChanged_1.distinctUntilChanged(), switchMap_1.switchMap(function (formInputs) {\n        if (!formInputs) {\n            return empty_1.empty();\n        }\n        return fromEvent_1.fromEvent(document.body, \"keyup\", true).pipe(map_1.map(function (e) { return e.target || e.srcElement; }), filter_1.filter(function (target) {\n            return target.tagName === \"INPUT\" ||\n                target.tagName === \"TEXTAREA\";\n        }), withLatestFrom_1.withLatestFrom(canSync$), filter_1.filter(function (_a) {\n            var canSync = _a[1];\n            return canSync;\n        }), map_1.map(function (_a) {\n            var eventTarget = _a[0];\n            var target = browser_utils_1.getElementData(eventTarget);\n            var value = eventTarget.value;\n            return KeyupEvent.outgoing(target, value);\n        }));\n    }));\n}\nexports.getFormInputStream = getFormInputStream;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/listeners/form-inputs.listener.ts?");

/***/ }),

/***/ "./lib/listeners/form-toggles.listener.ts":
/*!************************************************!*\
  !*** ./lib/listeners/form-toggles.listener.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar socket_messages_1 = __webpack_require__(/*! ../socket-messages */ \"./lib/socket-messages.ts\");\nvar browser_utils_1 = __webpack_require__(/*! ../browser.utils */ \"./lib/browser.utils.ts\");\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./lib/utils.ts\");\nvar FormToggleEvent = __webpack_require__(/*! ../messages/FormToggleEvent */ \"./lib/messages/FormToggleEvent.ts\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar skip_1 = __webpack_require__(/*! rxjs/operators/skip */ \"./node_modules/rxjs/operators/skip.js\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar distinctUntilChanged_1 = __webpack_require__(/*! rxjs/operators/distinctUntilChanged */ \"./node_modules/rxjs/operators/distinctUntilChanged.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar switchMap_1 = __webpack_require__(/*! rxjs/operators/switchMap */ \"./node_modules/rxjs/operators/switchMap.js\");\nvar empty_1 = __webpack_require__(/*! rxjs/observable/empty */ \"./node_modules/rxjs/observable/empty.js\");\nvar fromEvent_1 = __webpack_require__(/*! rxjs/observable/fromEvent */ \"./node_modules/rxjs/observable/fromEvent.js\");\nfunction getFormTogglesStream(document, socket$, option$) {\n    var canSync$ = utils_1.createTimedBooleanSwitch(socket$.pipe(filter_1.filter(function (_a) {\n        var name = _a[0];\n        return name === socket_messages_1.IncomingSocketNames.InputToggle;\n    })));\n    return option$.pipe(skip_1.skip(1), pluck_1.pluck(\"ghostMode\", \"forms\", \"toggles\"), distinctUntilChanged_1.distinctUntilChanged(), switchMap_1.switchMap(function (canToggle) {\n        if (!canToggle) {\n            return empty_1.empty();\n        }\n        return fromEvent_1.fromEvent(document, \"change\", true).pipe(map_1.map(function (e) { return e.target || e.srcElement; }), filter_1.filter(function (elem) { return elem.tagName === \"SELECT\"; }), withLatestFrom_1.withLatestFrom(canSync$), filter_1.filter(function (_a) {\n            var canSync = _a[1];\n            return canSync;\n        }), map_1.map(function (_a) {\n            var elem = _a[0], canSync = _a[1];\n            var data = browser_utils_1.getElementData(elem);\n            return FormToggleEvent.outgoing(data, {\n                type: elem.type,\n                checked: elem.checked,\n                value: elem.value\n            });\n        }));\n    }));\n}\nexports.getFormTogglesStream = getFormTogglesStream;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/listeners/form-toggles.listener.ts?");

/***/ }),

/***/ "./lib/listeners/scroll.listener.ts":
/*!******************************************!*\
  !*** ./lib/listeners/scroll.listener.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./lib/utils.ts\");\nvar socket_messages_1 = __webpack_require__(/*! ../socket-messages */ \"./lib/socket-messages.ts\");\nvar browser_utils_1 = __webpack_require__(/*! ../browser.utils */ \"./lib/browser.utils.ts\");\nvar ScrollEvent = __webpack_require__(/*! ../messages/ScrollEvent */ \"./lib/messages/ScrollEvent.ts\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar distinctUntilChanged_1 = __webpack_require__(/*! rxjs/operators/distinctUntilChanged */ \"./node_modules/rxjs/operators/distinctUntilChanged.js\");\nvar switchMap_1 = __webpack_require__(/*! rxjs/operators/switchMap */ \"./node_modules/rxjs/operators/switchMap.js\");\nvar empty_1 = __webpack_require__(/*! rxjs/observable/empty */ \"./node_modules/rxjs/observable/empty.js\");\nvar skip_1 = __webpack_require__(/*! rxjs/operators/skip */ \"./node_modules/rxjs/operators/skip.js\");\nvar fromEvent_1 = __webpack_require__(/*! rxjs/observable/fromEvent */ \"./node_modules/rxjs/observable/fromEvent.js\");\nfunction getScrollStream(window, document, socket$, option$) {\n    var canSync$ = utils_1.createTimedBooleanSwitch(socket$.pipe(filter_1.filter(function (_a) {\n        var name = _a[0];\n        return name === socket_messages_1.IncomingSocketNames.Scroll;\n    })));\n    /**\n     * If the option 'scrollElementMapping' is provided\n     * we cache thw\n     * @type {Observable<(Element | null)[]>}\n     */\n    var elemMap$ = option$.pipe(pluck_1.pluck(\"scrollElementMapping\"), map_1.map(function (selectors) {\n        return selectors.map(function (selector) { return document.querySelector(selector); });\n    }));\n    return option$.pipe(skip_1.skip(1), // initial option set before the connection event\n    pluck_1.pluck(\"ghostMode\", \"scroll\"), distinctUntilChanged_1.distinctUntilChanged(), switchMap_1.switchMap(function (scroll) {\n        if (!scroll)\n            return empty_1.empty();\n        return fromEvent_1.fromEvent(document, \"scroll\", true).pipe(map_1.map(function (e) { return e.target; }), withLatestFrom_1.withLatestFrom(canSync$, elemMap$), filter_1.filter(function (_a) {\n            var canSync = _a[1];\n            return Boolean(canSync);\n        }), map_1.map(function (_a) {\n            var target = _a[0], canSync = _a[1], elemMap = _a[2];\n            if (target === document) {\n                return ScrollEvent.outgoing(browser_utils_1.getScrollPosition(window, document), \"document\", 0);\n            }\n            var elems = document.getElementsByTagName(target.tagName);\n            var index = Array.prototype.indexOf.call(elems || [], target);\n            return ScrollEvent.outgoing(browser_utils_1.getScrollPositionForElement(target), target.tagName, index, elemMap.indexOf(target));\n        }));\n    }));\n}\nexports.getScrollStream = getScrollStream;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/listeners/scroll.listener.ts?");

/***/ }),

/***/ "./lib/log.ts":
/*!********************!*\
  !*** ./lib/log.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar _a;\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar timer_1 = __webpack_require__(/*! rxjs/observable/timer */ \"./node_modules/rxjs/observable/timer.js\");\nvar of_1 = __webpack_require__(/*! rxjs/observable/of */ \"./node_modules/rxjs/observable/of.js\");\nvar logger_1 = __webpack_require__(/*! ../vendor/logger */ \"./vendor/logger.ts\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar switchMap_1 = __webpack_require__(/*! rxjs/operators/switchMap */ \"./node_modules/rxjs/operators/switchMap.js\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nfunction initLogger(options) {\n    var log = new logger_1.Nanologger(options.logPrefix || \"\", {\n        colors: { magenta: \"#0F2634\" }\n    });\n    return of_1.of(log);\n}\nexports.initLogger = initLogger;\nvar LogNames;\n(function (LogNames) {\n    LogNames[\"Log\"] = \"@@Log\";\n    LogNames[\"Info\"] = \"@@Log.info\";\n    LogNames[\"Debug\"] = \"@@Log.debug\";\n})(LogNames = exports.LogNames || (exports.LogNames = {}));\nvar Overlay;\n(function (Overlay) {\n    Overlay[\"Info\"] = \"@@Overlay.info\";\n})(Overlay = exports.Overlay || (exports.Overlay = {}));\nfunction consoleInfo() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return [LogNames.Log, [LogNames.Info, args]];\n}\nexports.consoleInfo = consoleInfo;\nfunction consoleDebug() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return [LogNames.Log, [LogNames.Debug, args]];\n}\nexports.consoleDebug = consoleDebug;\nfunction overlayInfo(message, timeout) {\n    if (timeout === void 0) { timeout = 2000; }\n    return [Overlay.Info, [message, timeout]];\n}\nexports.overlayInfo = overlayInfo;\nexports.logHandler$ = new BehaviorSubject_1.BehaviorSubject((_a = {},\n    _a[LogNames.Log] = function (xs, inputs) {\n        return xs.pipe(\n        /**\n         * access injectNotification from the options stream\n         */\n        withLatestFrom_1.withLatestFrom(inputs.logInstance$, inputs.option$.pipe(pluck_1.pluck(\"injectNotification\"))), \n        /**\n         * only accept messages if injectNotification !== console\n         */\n        filter_1.filter(function (_a) {\n            var injectNotification = _a[2];\n            return injectNotification === \"console\";\n        }), tap_1.tap(function (_a) {\n            var event = _a[0], log = _a[1];\n            switch (event[0]) {\n                case LogNames.Info: {\n                    return log.info.apply(log, event[1]);\n                }\n                case LogNames.Debug: {\n                    return log.debug.apply(log, event[1]);\n                }\n            }\n        }));\n    },\n    _a[Overlay.Info] = function (xs, inputs) {\n        return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$, inputs.notifyElement$, inputs.document$), \n        /**\n         * Reject all notifications if notify: false\n         */\n        filter_1.filter(function (_a) {\n            var options = _a[1];\n            return Boolean(options.notify);\n        }), \n        /**\n         * Set the HTML of the notify element\n         */\n        tap_1.tap(function (_a) {\n            var event = _a[0], options = _a[1], element = _a[2], document = _a[3];\n            element.innerHTML = event[0];\n            element.style.display = \"block\";\n            document.body.appendChild(element);\n        }), \n        /**\n         * Now remove the element after the given timeout\n         */\n        switchMap_1.switchMap(function (_a) {\n            var event = _a[0], options = _a[1], element = _a[2], document = _a[3];\n            return timer_1.timer(event[1] || 2000).pipe(tap_1.tap(function () {\n                element.style.display = \"none\";\n                if (element.parentNode) {\n                    document.body.removeChild(element);\n                }\n            }));\n        }));\n    },\n    _a));\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/log.ts?");

/***/ }),

/***/ "./lib/messages/BrowserLocation.ts":
/*!*****************************************!*\
  !*** ./lib/messages/BrowserLocation.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar browser_set_location_effect_1 = __webpack_require__(/*! ../effects/browser-set-location.effect */ \"./lib/effects/browser-set-location.effect.ts\");\nfunction incomingBrowserLocation(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$.pipe(pluck_1.pluck(\"ghostMode\", \"location\"))), filter_1.filter(function (_a) {\n        var canSyncLocation = _a[1];\n        return canSyncLocation === true;\n    }), map_1.map(function (_a) {\n        var event = _a[0];\n        return browser_set_location_effect_1.browserSetLocation(event);\n    }));\n}\nexports.incomingBrowserLocation = incomingBrowserLocation;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/BrowserLocation.ts?");

/***/ }),

/***/ "./lib/messages/BrowserNotify.ts":
/*!***************************************!*\
  !*** ./lib/messages/BrowserNotify.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar Log = __webpack_require__(/*! ../log */ \"./lib/log.ts\");\nfunction incomingBrowserNotify(xs) {\n    return xs.pipe(map_1.map(function (event) { return Log.overlayInfo(event.message, event.timeout); }));\n}\nexports.incomingBrowserNotify = incomingBrowserNotify;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/BrowserNotify.ts?");

/***/ }),

/***/ "./lib/messages/BrowserReload.ts":
/*!***************************************!*\
  !*** ./lib/messages/BrowserReload.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar mergeMap_1 = __webpack_require__(/*! rxjs/operators/mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\nvar concat_1 = __webpack_require__(/*! rxjs/observable/concat */ \"./node_modules/rxjs/observable/concat.js\");\nvar of_1 = __webpack_require__(/*! rxjs/observable/of */ \"./node_modules/rxjs/observable/of.js\");\nvar browser_reload_effect_1 = __webpack_require__(/*! ../effects/browser-reload.effect */ \"./lib/effects/browser-reload.effect.ts\");\nvar subscribeOn_1 = __webpack_require__(/*! rxjs/operators/subscribeOn */ \"./node_modules/rxjs/operators/subscribeOn.js\");\nvar async_1 = __webpack_require__(/*! rxjs/scheduler/async */ \"./node_modules/rxjs/scheduler/async.js\");\nfunction incomingBrowserReload(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$), filter_1.filter(function (_a) {\n        var event = _a[0], options = _a[1];\n        return options.codeSync;\n    }), mergeMap_1.mergeMap(reloadBrowserSafe));\n}\nexports.incomingBrowserReload = incomingBrowserReload;\nfunction reloadBrowserSafe() {\n    return concat_1.concat(\n    /**\n     * Emit a warning message allowing others to do some work\n     */\n    of_1.of(browser_reload_effect_1.preBrowserReload()), \n    /**\n     * On the next tick, perform the reload\n     */\n    of_1.of(browser_reload_effect_1.browserReload()).pipe(subscribeOn_1.subscribeOn(async_1.async)));\n}\nexports.reloadBrowserSafe = reloadBrowserSafe;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/BrowserReload.ts?");

/***/ }),

/***/ "./lib/messages/ClickEvent.ts":
/*!************************************!*\
  !*** ./lib/messages/ClickEvent.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar socket_messages_1 = __webpack_require__(/*! ../socket-messages */ \"./lib/socket-messages.ts\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar simulate_click_effect_1 = __webpack_require__(/*! ../effects/simulate-click.effect */ \"./lib/effects/simulate-click.effect.ts\");\nfunction outgoing(data) {\n    return [socket_messages_1.OutgoingSocketEvents.Click, data];\n}\nexports.outgoing = outgoing;\nfunction incomingHandler$(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$.pipe(pluck_1.pluck(\"ghostMode\", \"clicks\")), inputs.window$.pipe(pluck_1.pluck(\"location\", \"pathname\"))), filter_1.filter(function (_a) {\n        var event = _a[0], canClick = _a[1], pathname = _a[2];\n        return canClick && event.pathname === pathname;\n    }), map_1.map(function (_a) {\n        var event = _a[0];\n        return simulate_click_effect_1.simulateClick(event);\n    }));\n}\nexports.incomingHandler$ = incomingHandler$;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/ClickEvent.ts?");

/***/ }),

/***/ "./lib/messages/Connection.ts":
/*!************************************!*\
  !*** ./lib/messages/Connection.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar of_1 = __webpack_require__(/*! rxjs/observable/of */ \"./node_modules/rxjs/observable/of.js\");\nvar Log = __webpack_require__(/*! ../log */ \"./lib/log.ts\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar mergeMap_1 = __webpack_require__(/*! rxjs/operators/mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\nvar set_options_effect_1 = __webpack_require__(/*! ../effects/set-options.effect */ \"./lib/effects/set-options.effect.ts\");\nfunction incomingConnection(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$.pipe(pluck_1.pluck(\"logPrefix\"))), mergeMap_1.mergeMap(function (_a) {\n        var x = _a[0], logPrefix = _a[1];\n        var prefix = logPrefix\n            ? logPrefix + \": \"\n            : '';\n        return of_1.of(set_options_effect_1.setOptions(x), Log.overlayInfo(prefix + \"connected\"));\n    }));\n}\nexports.incomingConnection = incomingConnection;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/Connection.ts?");

/***/ }),

/***/ "./lib/messages/Disconnect.ts":
/*!************************************!*\
  !*** ./lib/messages/Disconnect.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar ignoreElements_1 = __webpack_require__(/*! rxjs/operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nfunction incomingDisconnect(xs) {\n    return xs.pipe(tap_1.tap(function (x) { return console.log(x); }), ignoreElements_1.ignoreElements());\n}\nexports.incomingDisconnect = incomingDisconnect;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/Disconnect.ts?");

/***/ }),

/***/ "./lib/messages/FileReload.ts":
/*!************************************!*\
  !*** ./lib/messages/FileReload.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar empty_1 = __webpack_require__(/*! rxjs/observable/empty */ \"./node_modules/rxjs/observable/empty.js\");\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./lib/utils.ts\");\nvar of_1 = __webpack_require__(/*! rxjs/observable/of */ \"./node_modules/rxjs/observable/of.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar mergeMap_1 = __webpack_require__(/*! rxjs/operators/mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\nvar file_reload_effect_1 = __webpack_require__(/*! ../effects/file-reload.effect */ \"./lib/effects/file-reload.effect.ts\");\nvar BrowserReload_1 = __webpack_require__(/*! ./BrowserReload */ \"./lib/messages/BrowserReload.ts\");\nfunction incomingFileReload(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$), filter_1.filter(function (_a) {\n        var event = _a[0], options = _a[1];\n        return options.codeSync;\n    }), mergeMap_1.mergeMap(function (_a) {\n        var event = _a[0], options = _a[1];\n        if (event.url || !options.injectChanges) {\n            return BrowserReload_1.reloadBrowserSafe();\n        }\n        if (event.basename && event.ext && utils_1.isBlacklisted(event)) {\n            return empty_1.empty();\n        }\n        return of_1.of(file_reload_effect_1.fileReload(event));\n    }));\n}\nexports.incomingFileReload = incomingFileReload;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/FileReload.ts?");

/***/ }),

/***/ "./lib/messages/FormToggleEvent.ts":
/*!*****************************************!*\
  !*** ./lib/messages/FormToggleEvent.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar socket_messages_1 = __webpack_require__(/*! ../socket-messages */ \"./lib/socket-messages.ts\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar set_element_toggle_value_effect_1 = __webpack_require__(/*! ../effects/set-element-toggle-value.effect */ \"./lib/effects/set-element-toggle-value.effect.ts\");\nfunction outgoing(element, props) {\n    return [\n        socket_messages_1.OutgoingSocketEvents.InputToggle,\n        __assign({}, element, props)\n    ];\n}\nexports.outgoing = outgoing;\nfunction incomingInputsToggles(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$.pipe(pluck_1.pluck(\"ghostMode\", \"forms\", \"toggles\")), inputs.window$.pipe(pluck_1.pluck(\"location\", \"pathname\"))), filter_1.filter(function (_a) {\n        var toggles = _a[1];\n        return toggles === true;\n    }), map_1.map(function (_a) {\n        var event = _a[0];\n        return set_element_toggle_value_effect_1.setElementToggleValue(event);\n    }));\n}\nexports.incomingInputsToggles = incomingInputsToggles;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/FormToggleEvent.ts?");

/***/ }),

/***/ "./lib/messages/KeyupEvent.ts":
/*!************************************!*\
  !*** ./lib/messages/KeyupEvent.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar socket_messages_1 = __webpack_require__(/*! ../socket-messages */ \"./lib/socket-messages.ts\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar set_element_value_effect_1 = __webpack_require__(/*! ../effects/set-element-value.effect */ \"./lib/effects/set-element-value.effect.ts\");\nfunction outgoing(element, value) {\n    return [\n        socket_messages_1.OutgoingSocketEvents.Keyup,\n        __assign({}, element, { value: value })\n    ];\n}\nexports.outgoing = outgoing;\nfunction incomingKeyupHandler(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$.pipe(pluck_1.pluck(\"ghostMode\", \"forms\", \"inputs\")), inputs.window$.pipe(pluck_1.pluck(\"location\", \"pathname\"))), filter_1.filter(function (_a) {\n        var event = _a[0], canKeyup = _a[1], pathname = _a[2];\n        return canKeyup && event.pathname === pathname;\n    }), map_1.map(function (_a) {\n        var event = _a[0];\n        return set_element_value_effect_1.setElementValue(event);\n    }));\n}\nexports.incomingKeyupHandler = incomingKeyupHandler;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/KeyupEvent.ts?");

/***/ }),

/***/ "./lib/messages/OptionsSet.ts":
/*!************************************!*\
  !*** ./lib/messages/OptionsSet.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar set_options_effect_1 = __webpack_require__(/*! ../effects/set-options.effect */ \"./lib/effects/set-options.effect.ts\");\nfunction incomingOptionsSet(xs) {\n    return xs.pipe(map_1.map(function (event) { return set_options_effect_1.setOptions(event.options); }));\n}\nexports.incomingOptionsSet = incomingOptionsSet;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/OptionsSet.ts?");

/***/ }),

/***/ "./lib/messages/ScrollEvent.ts":
/*!*************************************!*\
  !*** ./lib/messages/ScrollEvent.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar socket_messages_1 = __webpack_require__(/*! ../socket-messages */ \"./lib/socket-messages.ts\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar effects_1 = __webpack_require__(/*! ../effects */ \"./lib/effects.ts\");\nfunction outgoing(data, tagName, index, mappingIndex) {\n    if (mappingIndex === void 0) { mappingIndex = -1; }\n    return [\n        socket_messages_1.OutgoingSocketEvents.Scroll,\n        { position: data, tagName: tagName, index: index, mappingIndex: mappingIndex }\n    ];\n}\nexports.outgoing = outgoing;\nfunction incomingScrollHandler(xs, inputs) {\n    return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.option$.pipe(pluck_1.pluck(\"ghostMode\", \"scroll\")), inputs.window$.pipe(pluck_1.pluck(\"location\", \"pathname\"))), filter_1.filter(function (_a) {\n        var event = _a[0], canScroll = _a[1], pathname = _a[2];\n        return canScroll && event.pathname === pathname;\n    }), map_1.map(function (_a) {\n        var event = _a[0];\n        return [effects_1.EffectNames.BrowserSetScroll, event];\n    }));\n}\nexports.incomingScrollHandler = incomingScrollHandler;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/messages/ScrollEvent.ts?");

/***/ }),

/***/ "./lib/notify.ts":
/*!***********************!*\
  !*** ./lib/notify.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar styles = {\n    display: \"none\",\n    padding: \"15px\",\n    fontFamily: \"sans-serif\",\n    position: \"fixed\",\n    fontSize: \"0.9em\",\n    zIndex: 9999,\n    right: 0,\n    top: 0,\n    borderBottomLeftRadius: \"5px\",\n    backgroundColor: \"#1B2032\",\n    margin: 0,\n    color: \"white\",\n    textAlign: \"center\",\n    pointerEvents: \"none\"\n};\n/**\n * @param {IBrowserSyncOptions} options\n * @returns {BehaviorSubject<any>}\n */\nfunction initNotify(options) {\n    var cssStyles = styles;\n    var elem;\n    if (options.notify.styles) {\n        if (Object.prototype.toString.call(options.notify.styles) ===\n            \"[object Array]\") {\n            // handle original array behavior, replace all styles with a joined copy\n            cssStyles = options.notify.styles.join(\";\");\n        }\n        else {\n            for (var key in options.notify.styles) {\n                if (options.notify.styles.hasOwnProperty(key)) {\n                    cssStyles[key] = options.notify.styles[key];\n                }\n            }\n        }\n    }\n    elem = document.createElement(\"DIV\");\n    elem.id = \"__bs_notify__\";\n    if (typeof cssStyles === \"string\") {\n        elem.style.cssText = cssStyles;\n    }\n    else {\n        for (var rule in cssStyles) {\n            elem.style[rule] = cssStyles[rule];\n        }\n    }\n    return new BehaviorSubject_1.BehaviorSubject(elem);\n}\nexports.initNotify = initNotify;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/notify.ts?");

/***/ }),

/***/ "./lib/scroll-restore.ts":
/*!*******************************!*\
  !*** ./lib/scroll-restore.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar _a;\nvar browser_utils_1 = __webpack_require__(/*! ./browser.utils */ \"./lib/browser.utils.ts\");\nvar effects_1 = __webpack_require__(/*! ./effects */ \"./lib/effects.ts\");\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar empty_1 = __webpack_require__(/*! rxjs/observable/empty */ \"./node_modules/rxjs/observable/empty.js\");\nvar of_1 = __webpack_require__(/*! rxjs/observable/of */ \"./node_modules/rxjs/observable/of.js\");\nvar Log = __webpack_require__(/*! ./log */ \"./lib/log.ts\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar set_window_name_dom_effect_1 = __webpack_require__(/*! ./dom-effects/set-window-name.dom-effect */ \"./lib/dom-effects/set-window-name.dom-effect.ts\");\nvar set_scroll_dom_effect_1 = __webpack_require__(/*! ./dom-effects/set-scroll.dom-effect */ \"./lib/dom-effects/set-scroll.dom-effect.ts\");\nexports.PREFIX = \"<<BS_START>>\";\nexports.SUFFIX = \"<<BS_START>>\";\nexports.regex = new RegExp(exports.PREFIX + \"(.+?)\" + exports.SUFFIX, \"g\");\nfunction parseFromString(input) {\n    var match;\n    var last;\n    while ((match = exports.regex.exec(input))) {\n        last = match[1];\n    }\n    if (last) {\n        return JSON.parse(last);\n    }\n}\nfunction initWindowName(window) {\n    var saved = (function () {\n        /**\n         * On page load, check window.name for an existing\n         * BS json blob & parse it.\n         */\n        try {\n            return parseFromString(window.name);\n        }\n        catch (e) {\n            return {};\n        }\n    })();\n    /**\n     * Remove any existing BS json from window.name\n     * to ensure we don't interfere with any other\n     * libs who may be using it.\n     */\n    window.name = window.name.replace(exports.regex, \"\");\n    /**\n     * If the JSON was parsed correctly, try to\n     * find a scroll property and restore it.\n     */\n    if (saved && saved.bs && saved.bs.hardReload && saved.bs.scroll) {\n        var _a = saved.bs.scroll, x = _a.x, y = _a.y;\n        return of_1.of(set_scroll_dom_effect_1.setScroll(x, y), Log.consoleDebug(\"[ScrollRestore] x = \" + x + \" y = \" + y));\n    }\n    return empty_1.empty();\n}\nexports.initWindowName = initWindowName;\nexports.scrollRestoreHandlers$ = new BehaviorSubject_1.BehaviorSubject((_a = {},\n    // [EffectNames.SetOptions]: (xs, inputs: Inputs) => {\n    //     return xs.pipe(\n    //         withLatestFrom(inputs.window$),\n    //         take(1),\n    //         mergeMap(([options, window]) => {\n    //             if (options.scrollRestoreTechnique === \"window.name\") {\n    //                 return initWindowName(window);\n    //             }\n    //             return empty();\n    //         })\n    //     );\n    // },\n    /**\n     * Save the current scroll position\n     * before the browser is reloaded (via window.location.reload(true))\n     * @param xs\n     * @param {Inputs} inputs\n     */\n    _a[effects_1.EffectNames.PreBrowserReload] = function (xs, inputs) {\n        return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.window$, inputs.document$), map_1.map(function (_a) {\n            var window = _a[1], document = _a[2];\n            return [\n                window.name,\n                exports.PREFIX,\n                JSON.stringify({\n                    bs: {\n                        hardReload: true,\n                        scroll: browser_utils_1.getBrowserScrollPosition(window, document)\n                    }\n                }),\n                exports.SUFFIX\n            ].join(\"\");\n        }), map_1.map(function (value) { return set_window_name_dom_effect_1.setWindowName(value); }));\n    },\n    _a));\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/scroll-restore.ts?");

/***/ }),

/***/ "./lib/socket-messages.ts":
/*!********************************!*\
  !*** ./lib/socket-messages.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar _a;\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar withLatestFrom_1 = __webpack_require__(/*! rxjs/operators/withLatestFrom */ \"./node_modules/rxjs/operators/withLatestFrom.js\");\nvar ignoreElements_1 = __webpack_require__(/*! rxjs/operators/ignoreElements */ \"./node_modules/rxjs/operators/ignoreElements.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar pluck_1 = __webpack_require__(/*! rxjs/operators/pluck */ \"./node_modules/rxjs/operators/pluck.js\");\nvar ScrollEvent_1 = __webpack_require__(/*! ./messages/ScrollEvent */ \"./lib/messages/ScrollEvent.ts\");\nvar ClickEvent_1 = __webpack_require__(/*! ./messages/ClickEvent */ \"./lib/messages/ClickEvent.ts\");\nvar KeyupEvent_1 = __webpack_require__(/*! ./messages/KeyupEvent */ \"./lib/messages/KeyupEvent.ts\");\nvar BrowserNotify_1 = __webpack_require__(/*! ./messages/BrowserNotify */ \"./lib/messages/BrowserNotify.ts\");\nvar BrowserLocation_1 = __webpack_require__(/*! ./messages/BrowserLocation */ \"./lib/messages/BrowserLocation.ts\");\nvar BrowserReload_1 = __webpack_require__(/*! ./messages/BrowserReload */ \"./lib/messages/BrowserReload.ts\");\nvar FileReload_1 = __webpack_require__(/*! ./messages/FileReload */ \"./lib/messages/FileReload.ts\");\nvar Connection_1 = __webpack_require__(/*! ./messages/Connection */ \"./lib/messages/Connection.ts\");\nvar Disconnect_1 = __webpack_require__(/*! ./messages/Disconnect */ \"./lib/messages/Disconnect.ts\");\nvar FormToggleEvent_1 = __webpack_require__(/*! ./messages/FormToggleEvent */ \"./lib/messages/FormToggleEvent.ts\");\nvar OptionsSet_1 = __webpack_require__(/*! ./messages/OptionsSet */ \"./lib/messages/OptionsSet.ts\");\nvar IncomingSocketNames;\n(function (IncomingSocketNames) {\n    IncomingSocketNames[\"Connection\"] = \"connection\";\n    IncomingSocketNames[\"Disconnect\"] = \"disconnect\";\n    IncomingSocketNames[\"FileReload\"] = \"file:reload\";\n    IncomingSocketNames[\"BrowserReload\"] = \"browser:reload\";\n    IncomingSocketNames[\"BrowserLocation\"] = \"browser:location\";\n    IncomingSocketNames[\"BrowserNotify\"] = \"browser:notify\";\n    IncomingSocketNames[\"Scroll\"] = \"scroll\";\n    IncomingSocketNames[\"Click\"] = \"click\";\n    IncomingSocketNames[\"Keyup\"] = \"input:text\";\n    IncomingSocketNames[\"InputToggle\"] = \"input:toggles\";\n    IncomingSocketNames[\"OptionsSet\"] = \"options:set\";\n})(IncomingSocketNames = exports.IncomingSocketNames || (exports.IncomingSocketNames = {}));\nvar OutgoingSocketEvents;\n(function (OutgoingSocketEvents) {\n    OutgoingSocketEvents[\"Scroll\"] = \"@@outgoing/scroll\";\n    OutgoingSocketEvents[\"Click\"] = \"@@outgoing/click\";\n    OutgoingSocketEvents[\"Keyup\"] = \"@@outgoing/keyup\";\n    OutgoingSocketEvents[\"InputToggle\"] = \"@@outgoing/Toggle\";\n})(OutgoingSocketEvents = exports.OutgoingSocketEvents || (exports.OutgoingSocketEvents = {}));\nexports.socketHandlers$ = new BehaviorSubject_1.BehaviorSubject((_a = {},\n    _a[IncomingSocketNames.Connection] = Connection_1.incomingConnection,\n    _a[IncomingSocketNames.Disconnect] = Disconnect_1.incomingDisconnect,\n    _a[IncomingSocketNames.FileReload] = FileReload_1.incomingFileReload,\n    _a[IncomingSocketNames.BrowserReload] = BrowserReload_1.incomingBrowserReload,\n    _a[IncomingSocketNames.BrowserLocation] = BrowserLocation_1.incomingBrowserLocation,\n    _a[IncomingSocketNames.BrowserNotify] = BrowserNotify_1.incomingBrowserNotify,\n    _a[IncomingSocketNames.Scroll] = ScrollEvent_1.incomingScrollHandler,\n    _a[IncomingSocketNames.Click] = ClickEvent_1.incomingHandler$,\n    _a[IncomingSocketNames.Keyup] = KeyupEvent_1.incomingKeyupHandler,\n    _a[IncomingSocketNames.InputToggle] = FormToggleEvent_1.incomingInputsToggles,\n    _a[IncomingSocketNames.OptionsSet] = OptionsSet_1.incomingOptionsSet,\n    _a[OutgoingSocketEvents.Scroll] = emitWithPathname(IncomingSocketNames.Scroll),\n    _a[OutgoingSocketEvents.Click] = emitWithPathname(IncomingSocketNames.Click),\n    _a[OutgoingSocketEvents.Keyup] = emitWithPathname(IncomingSocketNames.Keyup),\n    _a[OutgoingSocketEvents.InputToggle] = emitWithPathname(IncomingSocketNames.InputToggle),\n    _a));\nfunction emitWithPathname(name) {\n    return function (xs, inputs) {\n        return xs.pipe(withLatestFrom_1.withLatestFrom(inputs.io$, inputs.window$.pipe(pluck_1.pluck(\"location\", \"pathname\"))), tap_1.tap(function (_a) {\n            var event = _a[0], io = _a[1], pathname = _a[2];\n            return io.emit(name, __assign({}, event, { pathname: pathname }));\n        }), ignoreElements_1.ignoreElements());\n    };\n}\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/socket-messages.ts?");

/***/ }),

/***/ "./lib/socket.ts":
/*!***********************!*\
  !*** ./lib/socket.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar socket = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/lib/index.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar BehaviorSubject_1 = __webpack_require__(/*! rxjs/BehaviorSubject */ \"./node_modules/rxjs/BehaviorSubject.js\");\nvar of_1 = __webpack_require__(/*! rxjs/observable/of */ \"./node_modules/rxjs/observable/of.js\");\nvar share_1 = __webpack_require__(/*! rxjs/operators/share */ \"./node_modules/rxjs/operators/share.js\");\n/**\n * Alias for socket.emit\n * @param name\n * @param data\n */\n// export function emit(name, data) {\n//     if (io && io.emit) {\n//         // send relative path of where the event is sent\n//         data.url = window.location.pathname;\n//         io.emit(name, data);\n//     }\n// }\n//\n// /**\n//  * Alias for socket.on\n//  * @param name\n//  * @param func\n//  */\n// export function on(name, func) {\n//     io.on(name, func);\n// }\nfunction initWindow() {\n    return of_1.of(window);\n}\nexports.initWindow = initWindow;\nfunction initDocument() {\n    return of_1.of(document);\n}\nexports.initDocument = initDocument;\nfunction initNavigator() {\n    return of_1.of(navigator);\n}\nexports.initNavigator = initNavigator;\nfunction initOptions() {\n    return new BehaviorSubject_1.BehaviorSubject(window.___browserSync___.options);\n}\nexports.initOptions = initOptions;\nfunction initSocket() {\n    /**\n     * @type {{emit: emit, on: on}}\n     */\n    var socketConfig = window.___browserSync___.socketConfig;\n    var socketUrl = window.___browserSync___.socketUrl;\n    var io = socket(socketUrl, socketConfig);\n    var onevent = io.onevent;\n    var socket$ = Observable_1.Observable.create(function (obs) {\n        io.onevent = function (packet) {\n            onevent.call(this, packet);\n            obs.next(packet.data);\n        };\n    }).pipe(share_1.share());\n    var io$ = new BehaviorSubject_1.BehaviorSubject(io);\n    /**\n     * *****BACK-COMPAT*******\n     * Scripts that come after Browsersync may rely on the previous window.___browserSync___.socket\n     */\n    window.___browserSync___.socket = io;\n    return { socket$: socket$, io$: io$ };\n}\nexports.initSocket = initSocket;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/socket.ts?");

/***/ }),

/***/ "./lib/utils.ts":
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar concat_1 = __webpack_require__(/*! rxjs/observable/concat */ \"./node_modules/rxjs/observable/concat.js\");\nvar timer_1 = __webpack_require__(/*! rxjs/observable/timer */ \"./node_modules/rxjs/observable/timer.js\");\nvar of_1 = __webpack_require__(/*! rxjs/observable/of */ \"./node_modules/rxjs/observable/of.js\");\nvar switchMap_1 = __webpack_require__(/*! rxjs/operators/switchMap */ \"./node_modules/rxjs/operators/switchMap.js\");\nvar startWith_1 = __webpack_require__(/*! rxjs/operators/startWith */ \"./node_modules/rxjs/operators/startWith.js\");\nvar mapTo_1 = __webpack_require__(/*! rxjs/operators/mapTo */ \"./node_modules/rxjs/operators/mapTo.js\");\nfunction each(incoming) {\n    return [].slice.call(incoming || []);\n}\nexports.each = each;\nexports.splitUrl = function (url) {\n    var hash, index, params;\n    if ((index = url.indexOf(\"#\")) >= 0) {\n        hash = url.slice(index);\n        url = url.slice(0, index);\n    }\n    else {\n        hash = \"\";\n    }\n    if ((index = url.indexOf(\"?\")) >= 0) {\n        params = url.slice(index);\n        url = url.slice(0, index);\n    }\n    else {\n        params = \"\";\n    }\n    return { url: url, params: params, hash: hash };\n};\nexports.pathFromUrl = function (url) {\n    var path;\n    (url = exports.splitUrl(url).url);\n    if (url.indexOf(\"file://\") === 0) {\n        path = url.replace(new RegExp(\"^file://(localhost)?\"), \"\");\n    }\n    else {\n        //                        http  :   // hostname  :8080  /\n        path = url.replace(new RegExp(\"^([^:]+:)?//([^:/]+)(:\\\\d*)?/\"), \"/\");\n    }\n    // decodeURI has special handling of stuff like semicolons, so use decodeURIComponent\n    return decodeURIComponent(path);\n};\nexports.pickBestMatch = function (path, objects, pathFunc) {\n    var score;\n    var bestMatch = { score: 0, object: null };\n    objects.forEach(function (object) {\n        score = exports.numberOfMatchingSegments(path, pathFunc(object));\n        if (score > bestMatch.score) {\n            bestMatch = { object: object, score: score };\n        }\n    });\n    if (bestMatch.score > 0) {\n        return bestMatch;\n    }\n    else {\n        return null;\n    }\n};\nexports.numberOfMatchingSegments = function (path1, path2) {\n    path1 = normalisePath(path1);\n    path2 = normalisePath(path2);\n    if (path1 === path2) {\n        return 10000;\n    }\n    var comps1 = path1.split(\"/\").reverse();\n    var comps2 = path2.split(\"/\").reverse();\n    var len = Math.min(comps1.length, comps2.length);\n    var eqCount = 0;\n    while (eqCount < len && comps1[eqCount] === comps2[eqCount]) {\n        ++eqCount;\n    }\n    return eqCount;\n};\nexports.pathsMatch = function (path1, path2) {\n    return exports.numberOfMatchingSegments(path1, path2) > 0;\n};\nfunction getLocation(url) {\n    var location = document.createElement(\"a\");\n    location.href = url;\n    if (location.host === \"\") {\n        location.href = location.href;\n    }\n    return location;\n}\nexports.getLocation = getLocation;\n/**\n * @param {string} search\n * @param {string} key\n * @param {string} suffix\n */\nfunction updateSearch(search, key, suffix) {\n    if (search === \"\") {\n        return \"?\" + suffix;\n    }\n    return (\"?\" +\n        search\n            .slice(1)\n            .split(\"&\")\n            .map(function (item) {\n            return item.split(\"=\");\n        })\n            .filter(function (tuple) {\n            return tuple[0] !== key;\n        })\n            .map(function (item) {\n            return [item[0], item[1]].join(\"=\");\n        })\n            .concat(suffix)\n            .join(\"&\"));\n}\nexports.updateSearch = updateSearch;\nvar blacklist = [\n    // never allow .map files through\n    function (incoming) {\n        return incoming.ext === \"map\";\n    }\n];\n/**\n * @param incoming\n * @returns {boolean}\n */\nfunction isBlacklisted(incoming) {\n    return blacklist.some(function (fn) {\n        return fn(incoming);\n    });\n}\nexports.isBlacklisted = isBlacklisted;\nfunction createTimedBooleanSwitch(source$, timeout) {\n    if (timeout === void 0) { timeout = 1000; }\n    return source$.pipe(switchMap_1.switchMap(function () {\n        return concat_1.concat(of_1.of(false), timer_1.timer(timeout).pipe(mapTo_1.mapTo(true)));\n    }), startWith_1.startWith(true));\n}\nexports.createTimedBooleanSwitch = createTimedBooleanSwitch;\nfunction array(incoming) {\n    return [].slice.call(incoming);\n}\nexports.array = array;\nfunction normalisePath(path) {\n    return path\n        .replace(/^\\/+/, \"\")\n        .replace(/\\\\/g, \"/\")\n        .toLowerCase();\n}\nexports.normalisePath = normalisePath;\n\n\n//# sourceURL=webpack://browser-sync-client/./lib/utils.ts?");

/***/ }),

/***/ "./vendor/Reloader.ts":
/*!****************************!*\
  !*** ./vendor/Reloader.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n *\n * With thanks to https://github.com/livereload/livereload-js\n * :) :) :)\n *\n */\nvar utils_1 = __webpack_require__(/*! ../lib/utils */ \"./lib/utils.ts\");\nvar empty_1 = __webpack_require__(/*! rxjs/observable/empty */ \"./node_modules/rxjs/observable/empty.js\");\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ \"./node_modules/rxjs/Observable.js\");\nvar merge_1 = __webpack_require__(/*! rxjs/observable/merge */ \"./node_modules/rxjs/observable/merge.js\");\nvar timer_1 = __webpack_require__(/*! rxjs/observable/timer */ \"./node_modules/rxjs/observable/timer.js\");\nvar from_1 = __webpack_require__(/*! rxjs/observable/from */ \"./node_modules/rxjs/observable/from.js\");\nvar filter_1 = __webpack_require__(/*! rxjs/operators/filter */ \"./node_modules/rxjs/operators/filter.js\");\nvar map_1 = __webpack_require__(/*! rxjs/operators/map */ \"./node_modules/rxjs/operators/map.js\");\nvar mergeMap_1 = __webpack_require__(/*! rxjs/operators/mergeMap */ \"./node_modules/rxjs/operators/mergeMap.js\");\nvar tap_1 = __webpack_require__(/*! rxjs/operators/tap */ \"./node_modules/rxjs/operators/tap.js\");\nvar mapTo_1 = __webpack_require__(/*! rxjs/operators/mapTo */ \"./node_modules/rxjs/operators/mapTo.js\");\nvar prop_set_dom_effect_1 = __webpack_require__(/*! ../lib/dom-effects/prop-set.dom-effect */ \"./lib/dom-effects/prop-set.dom-effect.ts\");\nvar style_set_dom_effect_1 = __webpack_require__(/*! ../lib/dom-effects/style-set.dom-effect */ \"./lib/dom-effects/style-set.dom-effect.ts\");\nvar link_replace_dom_effect_1 = __webpack_require__(/*! ../lib/dom-effects/link-replace.dom-effect */ \"./lib/dom-effects/link-replace.dom-effect.ts\");\nvar mergeAll_1 = __webpack_require__(/*! rxjs/operators/mergeAll */ \"./node_modules/rxjs/operators/mergeAll.js\");\nvar hiddenElem;\nvar IMAGE_STYLES = [\n    { selector: 'background', styleNames: ['backgroundImage'] },\n    { selector: 'border', styleNames: ['borderImage', 'webkitBorderImage', 'MozBorderImage'] }\n];\nvar attrs = {\n    link: \"href\",\n    img: \"src\",\n    script: \"src\"\n};\nfunction reload(document, navigator) {\n    return function (data, options) {\n        var path = data.path;\n        if (options.liveCSS) {\n            if (path.match(/\\.css$/i)) {\n                return reloadStylesheet(path, document, navigator);\n            }\n        }\n        if (options.liveImg) {\n            if (path.match(/\\.(jpe?g|png|gif)$/i)) {\n                return reloadImages(path, document);\n            }\n        }\n        /**\n         * LEGACY\n         */\n        var domData = getElems(data.ext, options, document);\n        var elems = getMatches(domData.elems, data.basename, domData.attr);\n        for (var i = 0, n = elems.length; i < n; i += 1) {\n            swapFile(elems[i], domData, options, document, navigator);\n        }\n        return empty_1.empty();\n    };\n    function getMatches(elems, url, attr) {\n        if (url[0] === \"*\") {\n            return elems;\n        }\n        var matches = [];\n        var urlMatcher = new RegExp(\"(^|/)\" + url);\n        for (var i = 0, len = elems.length; i < len; i += 1) {\n            if (urlMatcher.test(elems[i][attr])) {\n                matches.push(elems[i]);\n            }\n        }\n        return matches;\n    }\n    function getElems(fileExtension, options, document) {\n        var tagName = options.tagNames[fileExtension];\n        var attr = attrs[tagName];\n        return {\n            attr: attr,\n            tagName: tagName,\n            elems: document.getElementsByTagName(tagName)\n        };\n    }\n    function reloadImages(path, document) {\n        var expando = generateUniqueString(Date.now());\n        return merge_1.merge(from_1.from([].slice.call(document.images))\n            .pipe(filter_1.filter(function (img) { return utils_1.pathsMatch(path, utils_1.pathFromUrl(img.src)); }), map_1.map(function (img) {\n            var payload = {\n                target: img,\n                prop: 'src',\n                value: generateCacheBustUrl(img.src, expando),\n                pathname: utils_1.getLocation(img.src).pathname\n            };\n            return prop_set_dom_effect_1.propSet(payload);\n        })), from_1.from(IMAGE_STYLES)\n            .pipe(mergeMap_1.mergeMap(function (_a) {\n            var selector = _a.selector, styleNames = _a.styleNames;\n            return from_1.from(document.querySelectorAll(\"[style*=\" + selector + \"]\")).pipe(mergeMap_1.mergeMap(function (img) {\n                return reloadStyleImages(img.style, styleNames, path, expando);\n            }));\n        })));\n        // if (document.styleSheets) {\n        //     return [].slice.call(document.styleSheets)\n        //         .map((styleSheet) => {\n        //             return reloadStylesheetImages(styleSheet, path, expando);\n        //         });\n        // }\n    }\n    function reloadStylesheetImages(styleSheet, path, expando) {\n        var rules;\n        try {\n            rules = styleSheet != null ? styleSheet.cssRules : undefined;\n        }\n        catch (e) { }\n        //\n        if (!rules) {\n            return;\n        }\n        [].slice.call(rules).forEach(function (rule) {\n            switch (rule.type) {\n                case CSSRule.IMPORT_RULE:\n                    reloadStylesheetImages(rule.styleSheet, path, expando);\n                    break;\n                case CSSRule.STYLE_RULE:\n                    [].slice.call(IMAGE_STYLES).forEach(function (_a) {\n                        var styleNames = _a.styleNames;\n                        reloadStyleImages(rule.style, styleNames, path, expando);\n                    });\n                    break;\n                case CSSRule.MEDIA_RULE:\n                    reloadStylesheetImages(rule, path, expando);\n                    break;\n            }\n        });\n    }\n    function reloadStyleImages(style, styleNames, path, expando) {\n        return from_1.from(styleNames).pipe(filter_1.filter(function (styleName) { return typeof style[styleName] === 'string'; }), map_1.map(function (styleName) {\n            var pathName;\n            var value = style[styleName];\n            var newValue = value.replace(new RegExp(\"\\\\burl\\\\s*\\\\(([^)]*)\\\\)\"), function (match, src) {\n                var _src = src;\n                if (src[0] === '\"' && src[src.length - 1] === '\"') {\n                    _src = src.slice(1, -1);\n                }\n                pathName = utils_1.getLocation(_src).pathname;\n                if (utils_1.pathsMatch(path, utils_1.pathFromUrl(_src))) {\n                    return \"url(\" + generateCacheBustUrl(_src, expando) + \")\";\n                }\n                else {\n                    return match;\n                }\n            });\n            return [\n                style,\n                styleName,\n                value,\n                newValue,\n                pathName\n            ];\n        }), filter_1.filter(function (_a) {\n            var style = _a[0], styleName = _a[1], value = _a[2], newValue = _a[3];\n            return newValue !== value;\n        }), map_1.map(function (_a) {\n            var style = _a[0], styleName = _a[1], value = _a[2], newValue = _a[3], pathName = _a[4];\n            return style_set_dom_effect_1.styleSet({ style: style, styleName: styleName, value: value, newValue: newValue, pathName: pathName });\n        }));\n    }\n    function swapFile(elem, domData, options, document, navigator) {\n        var attr = domData.attr;\n        var currentValue = elem[attr];\n        var timeStamp = new Date().getTime();\n        var key = \"browsersync-legacy\";\n        var suffix = key + \"=\" + timeStamp;\n        var anchor = utils_1.getLocation(currentValue);\n        var search = utils_1.updateSearch(anchor.search, key, suffix);\n        switch (domData.tagName) {\n            case 'link': {\n                // this.logger.trace(`replacing LINK ${attr}`);\n                reloadStylesheet(currentValue, document, navigator);\n                break;\n            }\n            case 'img': {\n                reloadImages(currentValue, document);\n                break;\n            }\n            default: {\n                if (options.timestamps === false) {\n                    elem[attr] = anchor.href;\n                }\n                else {\n                    elem[attr] = anchor.href.split(\"?\")[0] + search;\n                }\n                // this.logger.info(`reloading ${elem[attr]}`);\n                setTimeout(function () {\n                    if (!hiddenElem) {\n                        hiddenElem = document.createElement(\"DIV\");\n                        document.body.appendChild(hiddenElem);\n                    }\n                    else {\n                        hiddenElem.style.display = \"none\";\n                        hiddenElem.style.display = \"block\";\n                    }\n                }, 200);\n            }\n        }\n        return {\n            elem: elem,\n            timeStamp: timeStamp\n        };\n    }\n    function reattachStylesheetLink(link, document, navigator) {\n        // ignore LINKs that will be removed by LR soon\n        var clone;\n        if (link.__LiveReload_pendingRemoval) {\n            return empty_1.empty();\n        }\n        link.__LiveReload_pendingRemoval = true;\n        if (link.tagName === 'STYLE') {\n            // prefixfree\n            clone = document.createElement('link');\n            clone.rel = 'stylesheet';\n            clone.media = link.media;\n            clone.disabled = link.disabled;\n        }\n        else {\n            clone = link.cloneNode(false);\n        }\n        var prevHref = link.href;\n        var nextHref = generateCacheBustUrl(linkHref(link));\n        clone.href = nextHref;\n        var pathname = utils_1.getLocation(nextHref).pathname;\n        var basename = pathname.split('/').slice(-1)[0];\n        // insert the new LINK before the old one\n        var parent = link.parentNode;\n        if (parent.lastChild === link) {\n            parent.appendChild(clone);\n        }\n        else {\n            parent.insertBefore(clone, link.nextSibling);\n        }\n        var additionalWaitingTime;\n        if (/AppleWebKit/.test(navigator.userAgent)) {\n            additionalWaitingTime = 5;\n        }\n        else {\n            additionalWaitingTime = 200;\n        }\n        return Observable_1.Observable.create(function (obs) {\n            clone.onload = function () {\n                obs.next(true);\n                obs.complete();\n            };\n        })\n            .pipe(mergeMap_1.mergeMap(function () {\n            return timer_1.timer(additionalWaitingTime)\n                .pipe(tap_1.tap(function () {\n                if (link && !link.parentNode) {\n                    return;\n                }\n                link.parentNode.removeChild(link);\n                clone.onreadystatechange = null;\n            }), mapTo_1.mapTo(link_replace_dom_effect_1.linkReplace({ target: clone, nextHref: nextHref, prevHref: prevHref, pathname: pathname, basename: basename })));\n        }));\n    }\n    function reattachImportedRule(_a, document) {\n        var rule = _a.rule, index = _a.index, link = _a.link;\n        var parent = rule.parentStyleSheet;\n        var href = generateCacheBustUrl(rule.href);\n        var media = rule.media.length ? [].join.call(rule.media, ', ') : '';\n        var newRule = \"@import url(\\\"\" + href + \"\\\") \" + media + \";\";\n        // used to detect if reattachImportedRule has been called again on the same rule\n        rule.__LiveReload_newHref = href;\n        // WORKAROUND FOR WEBKIT BUG: WebKit resets all styles if we add @import'ed\n        // stylesheet that hasn't been cached yet. Workaround is to pre-cache the\n        // stylesheet by temporarily adding it as a LINK tag.\n        var tempLink = document.createElement(\"link\");\n        tempLink.rel = 'stylesheet';\n        tempLink.href = href;\n        tempLink.__LiveReload_pendingRemoval = true; // exclude from path matching\n        if (link.parentNode) {\n            link.parentNode.insertBefore(tempLink, link);\n        }\n        return timer_1.timer(200)\n            .pipe(tap_1.tap(function () {\n            if (tempLink.parentNode) {\n                tempLink.parentNode.removeChild(tempLink);\n            }\n            // if another reattachImportedRule call is in progress, abandon this one\n            if (rule.__LiveReload_newHref !== href) {\n                return;\n            }\n            parent.insertRule(newRule, index);\n            parent.deleteRule(index + 1);\n            // save the new rule, so that we can detect another reattachImportedRule call\n            rule = parent.cssRules[index];\n            rule.__LiveReload_newHref = href;\n        }), mergeMap_1.mergeMap(function () {\n            return timer_1.timer(200).pipe(tap_1.tap(function () {\n                // if another reattachImportedRule call is in progress, abandon this one\n                if (rule.__LiveReload_newHref !== href) {\n                    return;\n                }\n                parent.insertRule(newRule, index);\n                return parent.deleteRule(index + 1);\n            }));\n        }));\n    }\n    function generateCacheBustUrl(url, expando) {\n        if (expando === void 0) { expando = generateUniqueString(Date.now()); }\n        var _a;\n        var hash, oldParams;\n        (_a = utils_1.splitUrl(url), url = _a.url, hash = _a.hash, oldParams = _a.params);\n        // if (this.options.overrideURL) {\n        //     if (url.indexOf(this.options.serverURL) < 0) {\n        //         const originalUrl = url;\n        //         url = this.options.serverURL + this.options.overrideURL + \"?url=\" + encodeURIComponent(url);\n        //         this.logger.debug(`overriding source URL ${originalUrl} with ${url}`);\n        //     }\n        // }\n        var params = oldParams.replace(/(\\?|&)browsersync=(\\d+)/, function (match, sep) { return \"\" + sep + expando; });\n        if (params === oldParams) {\n            if (oldParams.length === 0) {\n                params = \"?\" + expando;\n            }\n            else {\n                params = oldParams + \"&\" + expando;\n            }\n        }\n        return url + params + hash;\n    }\n    function reloadStylesheet(path, document, navigator) {\n        // has to be a real array, because DOMNodeList will be modified\n        var links = utils_1.array(document.getElementsByTagName('link'))\n            .filter(function (link) {\n            return link.rel.match(/^stylesheet$/i)\n                && !link.__LiveReload_pendingRemoval;\n        });\n        /**\n         * Find imported style sheets in <style> tags\n         * @type {any[]}\n         */\n        var styleImported = utils_1.array(document.getElementsByTagName('style'))\n            .filter(function (style) { return Boolean(style.sheet); })\n            .reduce(function (acc, style) {\n            return acc.concat(collectImportedStylesheets(style, style.sheet));\n        }, []);\n        /**\n         * Find imported style sheets in <link> tags\n         * @type {any[]}\n         */\n        var linksImported = links\n            .reduce(function (acc, link) {\n            return acc.concat(collectImportedStylesheets(link, link.sheet));\n        }, []);\n        /**\n         * Combine all links + sheets\n         */\n        var allRules = links.concat(styleImported, linksImported);\n        /**\n         * Which href best matches the incoming href?\n         */\n        var match = utils_1.pickBestMatch(path, allRules, function (l) { return utils_1.pathFromUrl(linkHref(l)); });\n        if (match) {\n            if (match.object && match.object.rule) {\n                return reattachImportedRule(match.object, document);\n            }\n            return reattachStylesheetLink(match.object, document, navigator);\n        }\n        else {\n            if (links.length) {\n                // no <link> elements matched, so was the path including '*'?\n                var _a = path.split('.'), first = _a[0], rest = _a.slice(1);\n                if (first === '*') {\n                    return from_1.from(links.map(function (link) { return reattachStylesheetLink(link, document, navigator); }))\n                        .pipe(mergeAll_1.mergeAll());\n                }\n            }\n        }\n        return empty_1.empty();\n    }\n    function collectImportedStylesheets(link, styleSheet) {\n        // in WebKit, styleSheet.cssRules is null for inaccessible stylesheets;\n        // Firefox/Opera may throw exceptions\n        var output = [];\n        collect(link, makeRules(styleSheet));\n        return output;\n        function makeRules(styleSheet) {\n            var rules;\n            try {\n                rules = styleSheet != null ? styleSheet.cssRules : undefined;\n            }\n            catch (e) { }\n            return rules;\n        }\n        function collect(link, rules) {\n            if (rules && rules.length) {\n                for (var index = 0; index < rules.length; index++) {\n                    var rule = rules[index];\n                    switch (rule.type) {\n                        case CSSRule.CHARSET_RULE:\n                            break;\n                        case CSSRule.IMPORT_RULE:\n                            output.push({ link: link, rule: rule, index: index, href: rule.href });\n                            collect(link, makeRules(rule.styleSheet));\n                            break;\n                        default:\n                            break; // import rules can only be preceded by charset rules\n                    }\n                }\n            }\n        }\n    }\n    function linkHref(link) {\n        // prefixfree uses data-href when it turns LINK into STYLE\n        return link.href || link.getAttribute('data-href');\n    }\n    function generateUniqueString(value) {\n        return \"browsersync=\" + value;\n    }\n}\nexports.reload = reload;\n\n\n//# sourceURL=webpack://browser-sync-client/./vendor/Reloader.ts?");

/***/ }),

/***/ "./vendor/logger.ts":
/*!**************************!*\
  !*** ./vendor/logger.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar emojis = {\n    trace: '🔍',\n    debug: '🐛',\n    info: '✨',\n    warn: '⚠️',\n    error: '🚨',\n    fatal: '💀'\n};\nvar levels = {\n    trace: 10,\n    debug: 20,\n    info: 30,\n    warn: 40,\n    error: 50,\n    fatal: 60\n};\nvar defaultColors = {\n    foreground: '#d3c0c8',\n    background: '#2d2d2d',\n    black: '#2d2d2d',\n    red: '#f2777a',\n    green: '#99cc99',\n    yellow: '#ffcc66',\n    blue: '#6699cc',\n    magenta: '#cc99cc',\n    cyan: '#66cccc',\n    white: '#d3d0c8',\n    brightBlack: '#747369'\n};\nvar Nanologger = /** @class */ (function () {\n    function Nanologger(name, opts) {\n        this.name = name;\n        this.opts = opts;\n        this._name = name || '';\n        this._colors = __assign({}, defaultColors, (opts.colors || {}));\n        try {\n            this.logLevel = window.localStorage.getItem('logLevel') || 'info';\n        }\n        catch (e) {\n            this.logLevel = 'info';\n        }\n        this._logLevel = levels[this.logLevel];\n    }\n    Nanologger.prototype.trace = function () {\n        var args = ['trace'];\n        for (var i = 0, len = arguments.length; i < len; i++)\n            args.push(arguments[i]);\n        this._print.apply(this, args);\n    };\n    Nanologger.prototype.debug = function () {\n        var args = ['debug'];\n        for (var i = 0, len = arguments.length; i < len; i++)\n            args.push(arguments[i]);\n        this._print.apply(this, args);\n    };\n    Nanologger.prototype.info = function () {\n        var args = ['info'];\n        for (var i = 0, len = arguments.length; i < len; i++)\n            args.push(arguments[i]);\n        this._print.apply(this, args);\n    };\n    Nanologger.prototype.warn = function () {\n        var args = ['warn'];\n        for (var i = 0, len = arguments.length; i < len; i++)\n            args.push(arguments[i]);\n        this._print.apply(this, args);\n    };\n    Nanologger.prototype.error = function () {\n        var args = ['error'];\n        for (var i = 0, len = arguments.length; i < len; i++)\n            args.push(arguments[i]);\n        this._print.apply(this, args);\n    };\n    Nanologger.prototype.fatal = function () {\n        var args = ['fatal'];\n        for (var i = 0, len = arguments.length; i < len; i++)\n            args.push(arguments[i]);\n        this._print.apply(this, args);\n    };\n    Nanologger.prototype._print = function (level) {\n        if (levels[level] < this._logLevel)\n            return;\n        // var time = getTimeStamp()\n        var emoji = emojis[level];\n        var name = this._name || 'unknown';\n        var msgColor = (level === 'error' || level.fatal)\n            ? this._colors.red\n            : level === 'warn'\n                ? this._colors.yellow\n                : this._colors.green;\n        var objs = [];\n        var args = [null];\n        var msg = emoji + ' %c%s';\n        // args.push(color(this._colors.brightBlack), time)\n        args.push(color(this._colors.magenta), name);\n        for (var i = 1, len = arguments.length; i < len; i++) {\n            var arg = arguments[i];\n            if (typeof arg === 'string') {\n                if (i === 1) {\n                    // first string argument is in color\n                    msg += ' %c%s';\n                    args.push(color(msgColor));\n                    args.push(arg);\n                }\n                else if (/ms$/.test(arg)) {\n                    // arguments finishing with 'ms', grey out\n                    msg += ' %c%s';\n                    args.push(color(this._colors.brightBlack));\n                    args.push(arg);\n                }\n                else {\n                    // normal colors\n                    msg += ' %c%s';\n                    args.push(color(this._colors.white));\n                    args.push(arg);\n                }\n            }\n            else if (typeof arg === 'number') {\n                msg += ' %c%d';\n                args.push(color(this._colors.magenta));\n                args.push(arg);\n            }\n            else {\n                objs.push(arg);\n            }\n        }\n        args[0] = msg;\n        objs.forEach(function (obj) {\n            args.push(obj);\n        });\n        // In IE/Edge console functions don't inherit from Function.prototype\n        // so this is necessary to get all the args applied.\n        Function.prototype.apply.apply(console.log, [console, args]);\n    };\n    return Nanologger;\n}());\nexports.Nanologger = Nanologger;\nfunction color(color) {\n    return 'color: ' + color + ';';\n}\nfunction getTimeStamp() {\n    var date = new Date();\n    var hours = pad(date.getHours().toString());\n    var minutes = pad(date.getMinutes().toString());\n    var seconds = pad(date.getSeconds().toString());\n    return hours + ':' + minutes + ':' + seconds;\n}\nfunction pad(str) {\n    return str.length !== 2 ? 0 + str : str;\n}\n\n\n//# sourceURL=webpack://browser-sync-client/./vendor/logger.ts?");

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/***/ ((module) => {

eval("\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/backo2/index.js?");

/***/ }),

/***/ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(chars){\n  \"use strict\";\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = chars.indexOf(base64[i]);\n      encoded2 = chars.indexOf(base64[i+1]);\n      encoded3 = chars.indexOf(base64[i+2]);\n      encoded4 = chars.indexOf(base64[i+3]);\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js?");

/***/ }),

/***/ "./node_modules/blob/index.js":
/*!************************************!*\
  !*** ./node_modules/blob/index.js ***!
  \************************************/
/***/ ((module) => {

eval("/**\r\n * Create a blob builder even when vendor prefixes exist\r\n */\r\n\r\nvar BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\r\n  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :\r\n  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\r\n  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : \r\n  false;\r\n\r\n/**\r\n * Check if Blob constructor is supported\r\n */\r\n\r\nvar blobSupported = (function() {\r\n  try {\r\n    var a = new Blob(['hi']);\r\n    return a.size === 2;\r\n  } catch(e) {\r\n    return false;\r\n  }\r\n})();\r\n\r\n/**\r\n * Check if Blob constructor supports ArrayBufferViews\r\n * Fails in Safari 6, so we need to map to ArrayBuffers there.\r\n */\r\n\r\nvar blobSupportsArrayBufferView = blobSupported && (function() {\r\n  try {\r\n    var b = new Blob([new Uint8Array([1,2])]);\r\n    return b.size === 2;\r\n  } catch(e) {\r\n    return false;\r\n  }\r\n})();\r\n\r\n/**\r\n * Check if BlobBuilder is supported\r\n */\r\n\r\nvar blobBuilderSupported = BlobBuilder\r\n  && BlobBuilder.prototype.append\r\n  && BlobBuilder.prototype.getBlob;\r\n\r\n/**\r\n * Helper function that maps ArrayBufferViews to ArrayBuffers\r\n * Used by BlobBuilder constructor and old browsers that didn't\r\n * support it in the Blob constructor.\r\n */\r\n\r\nfunction mapArrayBufferViews(ary) {\r\n  return ary.map(function(chunk) {\r\n    if (chunk.buffer instanceof ArrayBuffer) {\r\n      var buf = chunk.buffer;\r\n\r\n      // if this is a subarray, make a copy so we only\r\n      // include the subarray region from the underlying buffer\r\n      if (chunk.byteLength !== buf.byteLength) {\r\n        var copy = new Uint8Array(chunk.byteLength);\r\n        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\r\n        buf = copy.buffer;\r\n      }\r\n\r\n      return buf;\r\n    }\r\n\r\n    return chunk;\r\n  });\r\n}\r\n\r\nfunction BlobBuilderConstructor(ary, options) {\r\n  options = options || {};\r\n\r\n  var bb = new BlobBuilder();\r\n  mapArrayBufferViews(ary).forEach(function(part) {\r\n    bb.append(part);\r\n  });\r\n\r\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\r\n};\r\n\r\nfunction BlobConstructor(ary, options) {\r\n  return new Blob(mapArrayBufferViews(ary), options || {});\r\n};\r\n\r\nif (typeof Blob !== 'undefined') {\r\n  BlobBuilderConstructor.prototype = Blob.prototype;\r\n  BlobConstructor.prototype = Blob.prototype;\r\n}\r\n\r\nmodule.exports = (function() {\r\n  if (blobSupported) {\r\n    return blobSupportsArrayBufferView ? Blob : BlobConstructor;\r\n  } else if (blobBuilderSupported) {\r\n    return BlobBuilderConstructor;\r\n  } else {\r\n    return undefined;\r\n  }\r\n})();\r\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/blob/index.js?");

/***/ }),

/***/ "./node_modules/component-bind/index.js":
/*!**********************************************!*\
  !*** ./node_modules/component-bind/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/component-bind/index.js?");

/***/ }),

/***/ "./node_modules/component-inherit/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-inherit/index.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/component-inherit/index.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/globalThis.browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/globalThis.browser.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("module.exports = (function () {\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')(); // eslint-disable-line no-new-func\n  }\n})();\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/engine.io-client/lib/globalThis.browser.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./socket */ \"./node_modules/engine.io-client/lib/socket.js\");\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/engine.io-client/lib/index.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/socket.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nvar transports = __webpack_require__(/*! ./transports/index */ \"./node_modules/engine.io-client/lib/transports/index.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/engine.io-client/node_modules/component-emitter/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/engine.io-client/node_modules/debug/src/browser.js\")('engine.io-client:socket');\nvar index = __webpack_require__(/*! indexof */ \"./node_modules/indexof/index.js\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\nvar parseuri = __webpack_require__(/*! parseuri */ \"./node_modules/parseuri/index.js\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket (uri, opts) {\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.hostname = uri.host;\n    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  } else if (opts.host) {\n    opts.hostname = parseuri(opts.host).host;\n  }\n\n  this.secure = null != opts.secure ? opts.secure\n    : (typeof location !== 'undefined' && 'https:' === location.protocol);\n\n  if (opts.hostname && !opts.port) {\n    // if no port is specified manually, use the protocol default\n    opts.port = this.secure ? '443' : '80';\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (typeof location !== 'undefined' ? location.hostname : 'localhost');\n  this.port = opts.port || (typeof location !== 'undefined' && location.port\n      ? location.port\n      : (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.withCredentials = false !== opts.withCredentials;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.transportOptions = opts.transportOptions || {};\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.prevBufferLen = 0;\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n    this.perMessageDeflate.threshold = 1024;\n  }\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || undefined;\n  this.key = opts.key || undefined;\n  this.passphrase = opts.passphrase || undefined;\n  this.cert = opts.cert || undefined;\n  this.ca = opts.ca || undefined;\n  this.ciphers = opts.ciphers || undefined;\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;\n  this.forceNode = !!opts.forceNode;\n\n  // detect ReactNative environment\n  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');\n\n  // other options for Node.js or ReactNative client\n  if (typeof self === 'undefined' || this.isReactNative) {\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n      this.extraHeaders = opts.extraHeaders;\n    }\n\n    if (opts.localAddress) {\n      this.localAddress = opts.localAddress;\n    }\n  }\n\n  // set on handshake\n  this.id = null;\n  this.upgrades = null;\n  this.pingInterval = null;\n  this.pingTimeout = null;\n\n  // set on heartbeat\n  this.pingIntervalTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = __webpack_require__(/*! ./transport */ \"./node_modules/engine.io-client/lib/transport.js\");\nSocket.transports = __webpack_require__(/*! ./transports/index */ \"./node_modules/engine.io-client/lib/transports/index.js\");\nSocket.parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // per-transport options\n  var options = this.transportOptions[name] || {};\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    query: query,\n    socket: this,\n    agent: options.agent || this.agent,\n    hostname: options.hostname || this.hostname,\n    port: options.port || this.port,\n    secure: options.secure || this.secure,\n    path: options.path || this.path,\n    forceJSONP: options.forceJSONP || this.forceJSONP,\n    jsonp: options.jsonp || this.jsonp,\n    forceBase64: options.forceBase64 || this.forceBase64,\n    enablesXDR: options.enablesXDR || this.enablesXDR,\n    withCredentials: options.withCredentials || this.withCredentials,\n    timestampRequests: options.timestampRequests || this.timestampRequests,\n    timestampParam: options.timestampParam || this.timestampParam,\n    policyPort: options.policyPort || this.policyPort,\n    pfx: options.pfx || this.pfx,\n    key: options.key || this.key,\n    passphrase: options.passphrase || this.passphrase,\n    cert: options.cert || this.cert,\n    ca: options.ca || this.ca,\n    ciphers: options.ciphers || this.ciphers,\n    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,\n    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,\n    extraHeaders: options.extraHeaders || this.extraHeaders,\n    forceNode: options.forceNode || this.forceNode,\n    localAddress: options.localAddress || this.localAddress,\n    requestTimeout: options.requestTimeout || this.requestTimeout,\n    protocols: options.protocols || void (0),\n    isReactNative: this.isReactNative\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\n    transport = 'websocket';\n  } else if (0 === this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function () {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function () {\n    self.onDrain();\n  })\n  .on('packet', function (packet) {\n    self.onPacket(packet);\n  })\n  .on('error', function (e) {\n    self.onError(e);\n  })\n  .on('close', function () {\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 });\n  var failed = false;\n  var self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen () {\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' === msg.type && 'probe' === msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' === self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport () {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  // Handle any error that happens while probing\n  function onerror (err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose () {\n    onerror('transport closed');\n  }\n\n  // When the socket is closed while we're probing\n  function onclose () {\n    onerror('socket closed');\n  }\n\n  // When the socket is upgraded while we're probing\n  function onupgrade (to) {\n    if (transport && to.name !== transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  // Remove all listeners on the transport and on self\n  function cleanup () {\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' === this.readyState || 'open' === this.readyState ||\n      'closing' === this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(JSON.parse(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        this.emit('pong');\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.onError(err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if ('closed' === this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' === self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api private\n*/\n\nSocket.prototype.ping = function () {\n  var self = this;\n  this.sendPacket('ping', function () {\n    self.emit('ping');\n  });\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function () {\n  this.writeBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (0 === this.writeBuffer.length) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @param {Object} options.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, options, fn) {\n  this.sendPacket('message', msg, options, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Object} options.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, fn) {\n  if ('function' === typeof data) {\n    fn = data;\n    data = undefined;\n  }\n\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  if ('closing' === this.readyState || 'closed' === this.readyState) {\n    return;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  var packet = {\n    type: type,\n    data: data,\n    options: options\n  };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  if (fn) this.once('flush', fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function () {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  function close () {\n    self.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    self.transport.close();\n  }\n\n  function cleanupAndClose () {\n    self.removeListener('upgrade', cleanupAndClose);\n    self.removeListener('upgradeError', cleanupAndClose);\n    close();\n  }\n\n  function waitForUpgrade () {\n    // wait for upgrade to finish since we can't send packets while pausing a transport\n    self.once('upgrade', cleanupAndClose);\n    self.once('upgradeError', cleanupAndClose);\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n\n    // clean buffers after, so users can still\n    // grab the buffers on `close` event\n    self.writeBuffer = [];\n    self.prevBufferLen = 0;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i < j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/engine.io-client/lib/socket.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transport.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/engine.io-client/node_modules/component-emitter/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n  this.withCredentials = opts.withCredentials;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n  this.forceNode = opts.forceNode;\n\n  // results of ReactNative environment detection\n  this.isReactNative = opts.isReactNative;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n  this.localAddress = opts.localAddress;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' === this.readyState || '' === this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function (packets) {\n  if ('open' === this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function (data) {\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/engine.io-client/lib/transport.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\nvar XHR = __webpack_require__(/*! ./polling-xhr */ \"./node_modules/engine.io-client/lib/transports/polling-xhr.js\");\nvar JSONP = __webpack_require__(/*! ./polling-jsonp */ \"./node_modules/engine.io-client/lib/transports/polling-jsonp.js\");\nvar websocket = __webpack_require__(/*! ./websocket */ \"./node_modules/engine.io-client/lib/transports/websocket.js\");\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling (opts) {\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (typeof location !== 'undefined') {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname !== location.hostname || port !== opts.port;\n    xs = opts.secure !== isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/engine.io-client/lib/transports/index.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Module requirements.\n */\n\nvar Polling = __webpack_require__(/*! ./polling */ \"./node_modules/engine.io-client/lib/transports/polling.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar globalThis = __webpack_require__(/*! ../globalThis */ \"./node_modules/engine.io-client/lib/globalThis.browser.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    callbacks = globalThis.___eio = (globalThis.___eio || []);\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (typeof addEventListener === 'function') {\n    addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function (e) {\n    self.onError('jsonp poll error', e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  if (insertAt) {\n    insertAt.parentNode.insertBefore(script, insertAt);\n  } else {\n    (document.head || document.body).appendChild(script);\n  }\n  this.script = script;\n\n  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch (e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function () {\n      if (self.iframe.readyState === 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/engine.io-client/lib/transports/polling-jsonp.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* global attachEvent */\n\n/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\nvar Polling = __webpack_require__(/*! ./polling */ \"./node_modules/engine.io-client/lib/transports/polling.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/engine.io-client/node_modules/component-emitter/index.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/engine.io-client/node_modules/debug/src/browser.js\")('engine.io-client:polling-xhr');\nvar globalThis = __webpack_require__(/*! ../globalThis */ \"./node_modules/engine.io-client/lib/globalThis.browser.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty () {}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR (opts) {\n  Polling.call(this, opts);\n  this.requestTimeout = opts.requestTimeout;\n  this.extraHeaders = opts.extraHeaders;\n\n  if (typeof location !== 'undefined') {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||\n      port !== opts.port;\n    this.xs = opts.secure !== isSSL;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function (opts) {\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n  opts.withCredentials = this.withCredentials;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  opts.requestTimeout = this.requestTimeout;\n\n  // other options for Node.js client\n  opts.extraHeaders = this.extraHeaders;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function (data, fn) {\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function (err) {\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function () {\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function (data) {\n    self.onData(data);\n  });\n  req.on('error', function (err) {\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request (opts) {\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined !== opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n  this.withCredentials = opts.withCredentials;\n  this.requestTimeout = opts.requestTimeout;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function () {\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    try {\n      if (this.extraHeaders) {\n        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n        for (var i in this.extraHeaders) {\n          if (this.extraHeaders.hasOwnProperty(i)) {\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\n          }\n        }\n      }\n    } catch (e) {}\n\n    if ('POST' === this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    try {\n      xhr.setRequestHeader('Accept', '*/*');\n    } catch (e) {}\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = this.withCredentials;\n    }\n\n    if (this.requestTimeout) {\n      xhr.timeout = this.requestTimeout;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function () {\n        self.onLoad();\n      };\n      xhr.onerror = function () {\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 2) {\n          try {\n            var contentType = xhr.getResponseHeader('Content-Type');\n            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {\n              xhr.responseType = 'arraybuffer';\n            }\n          } catch (e) {}\n        }\n        if (4 !== xhr.readyState) return;\n        if (200 === xhr.status || 1223 === xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function () {\n            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function () {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (typeof document !== 'undefined') {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function () {\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function (data) {\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function (err) {\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function (fromError) {\n  if ('undefined' === typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch (e) {}\n  }\n\n  if (typeof document !== 'undefined') {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function () {\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type');\n    } catch (e) {}\n    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {\n      data = this.xhr.response || this.xhr.responseText;\n    } else {\n      data = this.xhr.responseText;\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function () {\n  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function () {\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nRequest.requestsCount = 0;\nRequest.requests = {};\n\nif (typeof document !== 'undefined') {\n  if (typeof attachEvent === 'function') {\n    attachEvent('onunload', unloadHandler);\n  } else if (typeof addEventListener === 'function') {\n    var terminationEvent = 'onpagehide' in globalThis ? 'pagehide' : 'unload';\n    addEventListener(terminationEvent, unloadHandler, false);\n  }\n}\n\nfunction unloadHandler () {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n\n//# sourceURL=webpack://browser-sync-client/./node_modules/engine.io-client/lib/transports/polling-xhr.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"./node_modules/engine.io-client/lib/transport.js\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar yeast = __webpack_require__(/*! yeast */ \"./node_modules/yeast/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/engine.io-client/node_modules/debug/src/browser.js\")('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function () {\n  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function () {\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function (onPause) {\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause () {\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function () {\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function () {\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function () {\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function (data) {\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function (packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' === self.readyState && packet.type === 'open') {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' === packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' !== this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' === this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function () {\n  var self = this;\n\n  function close () {\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' === this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n  var callbackfn = function () {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  